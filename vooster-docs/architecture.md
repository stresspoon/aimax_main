# 기술 요구사항 문서 (TRD)

## 1. 개요 기술 요약

### 프로젝트 개요
본 문서는 생성형 AI를 활용한 마케팅 콘텐츠 자동화 웹 서비스의 기술적 요구사항을 정의합니다. 프로젝트의 핵심 목표는 1인 사업자 및 소규모 마케터가 최소한의 노력으로 SEO 블로그 글, SNS 콘텐츠 등을 생성할 수 있는 플랫폼을 신속하게 구축하는 것입니다. 초기 단계에서는 시장의 빠른 진입을 위해 핵심 기능인 'AI 글쓰기'에 집중하며, 안정적이고 확장 가능한 기반을 마련하는 데 중점을 둡니다. 아키텍처는 MVP(최소 기능 제품)의 즉시 출시를 위해 단순화된 단일 백엔드 구조로 시작하며, 서비스 성장에 따라 점진적으로 고도화할 계획입니다.

### 핵심 기술 스택
- **프론트엔드**: Next.js (React), Tailwind CSS
- **백엔드**: Python (FastAPI)
- **데이터베이스**: PostgreSQL (주요 데이터), Redis (캐싱/세션), Amazon S3 (콘텐츠 저장)
- **AI 및 외부 연동**: Google Gemini API, Naver 검색어 트렌드 API, 소셜 로그인(OAuth 2.0)
- **인프라**: AWS App Runner (백엔드/프론트엔드 배포), Amazon RDS (PostgreSQL), Amazon ElastiCache (Redis)

### 주요 기술 목표
- **신속한 MVP 출시**: 8주 내에 로그인 및 핵심 글쓰기 기능을 포함한 MVP 버전 출시
- **안정적인 AI 연동**: Gemini 및 Naver API와의 안정적인 연동을 통해 일관된 품질의 콘텐츠 생성 보장
- **사용자 경험 최적화**: 실시간 글자 수 계산, 즉각적인 복사 기능 등 직관적이고 빠른 사용자 인터페이스 제공
- **확장성 기반 마련**: 향후 기능 추가 및 사용자 증가에 유연하게 대응할 수 있는 단순하고 명확한 코드 구조 설계

### 핵심 기술 가정
- 초기 사용자 트래픽은 복잡한 오토스케일링(예: Kubernetes) 없이 AWS App Runner의 기본 스케일링 기능으로 충분히 감당 가능하다고 가정합니다.
- 외부 API(Gemini, Naver)의 응답 속도 및 안정성이 서비스 전체 성능에 직접적인 영향을 미치므로, 이에 대한 예외 처리 및 비동기 처리가 필수적입니다.
- MVP 단계에서는 복잡한 데이터 분석 파이프라인(Kinesis, Redshift) 대신 기본적인 로그 수집 및 분석(CloudWatch)으로 충분합니다.

## 2. 기술 스택

| 범주 | 기술 / 라이브러리 | 선정 사유 |
| --- | --- | --- |
| **프론트엔드** | Next.js (React) | 요구사항에 명시됨. SEO 최적화에 유리하며, 서버 사이드 렌더링(SSR)을 통해 초기 로딩 성능을 개선할 수 있음. |
| | Tailwind CSS | 요구사항에 명시됨. 유틸리티 기반 스타일링으로 신속한 UI 개발 및 일관된 디자인 시스템 적용에 용이함. |
| **백엔드** | Python (FastAPI) | 요구사항에 명시됨. AI/ML 연동에 강점을 가지며, 비동기 처리를 지원하여 외부 API 호출이 많은 서비스에 적합. 개발 생산성이 높음. |
| **데이터베이스** | PostgreSQL | 요구사항에 명시됨. 정형 데이터(사용자 정보, 콘텐츠 메타데이터)를 안정적으로 관리하기 위한 관계형 데이터베이스. |
| | Redis | 요구사항에 명시됨. 외부 API 응답 결과 캐싱, 사용자 세션 관리 등을 통해 시스템 전반의 응답 속도를 향상시키기 위함. |
| | Amazon S3 | 요구사항에 명시됨. 생성된 글(HTML, TEXT) 및 관련 미디어 파일을 비용 효율적으로 저장하고 관리하기 위함. |
| **AI 모델** | Google Gemini API (gemini-2.5-pro) | 요구사항에 명시됨. 핵심 기능인 제목 및 본문 생성에 사용. 최신 모델을 활용하여 고품질의 결과물 도출. |
| **인프라/배포** | AWS App Runner | 컨테이너 기반 애플리케이션을 가장 빠르고 간단하게 배포 및 확장할 수 있는 관리형 서비스. MVP의 신속한 배포 목표에 부합. |
| **외부 연동** | Naver 검색어 트렌드 API | 요구사항에 명시됨. 사용자에게 연관 키워드를 추천하여 콘텐츠의 SEO 품질을 높이는 데 활용. |
| | OAuth 2.0 (소셜 로그인) | 사용자의 가입 및 로그인 허들을 낮추기 위한 표준 프로토콜. Google, Kakao 등 주요 플랫폼 연동. |

## 3. 시스템 아키텍처 설계

### 최상위 구성 요소
- **프론트엔드 (웹 애플리케이션)**: Next.js로 구축된 단일 페이지 애플리케이션(SPA). 사용자와의 모든 상호작용을 처리하며, AWS의 CDN(CloudFront)을 통해 전역 사용자에게 빠르게 제공됩니다.
  - 하위 구성 요소: UI 컴포넌트, 상태 관리, API 클라이언트, 라우팅
- **백엔드 API 서버**: Python FastAPI로 구현된 단일(Monolithic) API 서버. 사용자 인증, 비즈니스 로직 처리, 데이터베이스 연동 및 외부 AI/데이터 API 호출을 총괄합니다.
  - 하위 구성 요소: API 엔드포인트, 비즈니스 로직 서비스, 데이터베이스 접근 계층(ORM), 외부 API 연동 모듈
- **데이터 스토어**: 서비스의 데이터를 저장하고 관리하는 구성 요소 집합입니다.
  - 하위 구성 요소: Amazon RDS for PostgreSQL (영구 데이터), Amazon ElastiCache for Redis (임시/캐시 데이터), Amazon S3 (파일 객체)
- **외부 서비스**: 서비스의 핵심 기능을 위해 연동되는 제3자 API입니다.
  - 하위 구성 요소: Google Gemini API, Naver API, 소셜 로그인 제공자(IdP)

### 최상위 컴포넌트 상호작용 다이어그램
```mermaid
graph TD
    subgraph "사용자 환경"
        A[사용자 브라우저]
    end

    subgraph "AWS 클라우드"
        B[프론트엔드 (Next.js on App Runner/CloudFront)]
        C[백엔드 API (FastAPI on App Runner)]
        D[데이터베이스 (PostgreSQL on RDS)]
        E[캐시 (Redis on ElastiCache)]
        F[파일 스토리지 (S3)]
    end

    subgraph "외부 서비스"
        G[Google Gemini API]
        H[Naver API]
        I[소셜 로그인 제공자]
    end

    A -- HTTPS --> B
    B -- API 요청 --> C
    C -- 인증 요청 --> I
    C -- DB 쿼리 --> D
    C -- 캐시 조회/저장 --> E
    C -- 파일 업로드/다운로드 --> F
    C -- AI 생성 요청 --> G
    C -- 키워드 추천 요청 --> H
```

- **사용자 요청 처리**: 사용자는 브라우저를 통해 프론트엔드 애플리케이션에 접속합니다. 프론트엔드는 정적 콘텐츠를 제공하고 API 서버에 데이터(예: 글 생성 요청)를 보냅니다.
- **백엔드 로직 수행**: 백엔드 API 서버는 사용자 요청을 받아 인증(소셜 로그인)을 처리하고, 비즈니스 로직을 수행합니다. 글 생성 요청 시, Gemini API와 Naver API를 호출하여 필요한 데이터를 조합합니다.
- **데이터 관리**: 사용자 정보, 생성된 콘텐츠의 메타데이터 등은 PostgreSQL에 저장됩니다. 자주 사용되거나 생성 비용이 높은 데이터(예: API 응답)는 Redis에 캐싱하여 성능을 최적화합니다. 생성된 글의 원본 파일은 S3에 저장됩니다.
- **외부 API 연동**: 백엔드는 핵심 기능 구현을 위해 외부 서비스(Gemini, Naver)와 통신하며, 이 과정에서 발생할 수 있는 지연은 비동기 방식으로 처리하여 사용자 경험 저하를 최소화합니다.

### 코드 구조 및 컨벤션
**도메인 주도 구성 전략**
- **도메인 분리**: 비즈니스 도메인(예: 사용자 관리, 글쓰기, 인증)을 기준으로 코드를 구성하여 응집도를 높이고 결합도를 낮춥니다.
- **계층 기반 아키텍처**: 각 도메인 내에서는 프레젠테이션(API 엔드포인트), 비즈니스 로직(서비스), 데이터 접근(리포지토리) 계층으로 명확히 분리합니다.
- **기능 기반 모듈**: 특정 기능과 관련된 파일(예: 라우트, 서비스, 모델)을 하나의 폴더에 그룹화하여 관련 코드 파악을 용이하게 합니다.
- **공유 컴포넌트**: 공통 유틸리티, 설정, 타입 정의 등은 전용 공유 모듈에 배치하여 중복을 제거합니다.

**범용 파일 및 폴더 구조 (백엔드 FastAPI 기준)**
```
/
├── app/
│   ├── __init__.py
│   ├── main.py             # FastAPI 앱 초기화 및 미들웨어 설정
│   ├── core/               # 프로젝트 핵심 설정
│   │   ├── __init__.py
│   │   └── config.py       # 환경 변수, 설정 값 관리
│   ├── db/                 # 데이터베이스 연결 및 세션 관리
│   │   ├── __init__.py
│   │   └── session.py
│   ├── domains/            # 비즈니스 도메인별 모듈
│   │   ├── __init__.py
│   │   ├── auth/           # 인증 및 사용자 관리 도메인
│   │   │   ├── __init__.py
│   │   │   ├── auth_router.py
│   │   │   ├── auth_service.py
│   
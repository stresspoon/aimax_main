{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD) - 체험단 자동화 시스템\n\n## 1. 개요(Executive Summary)\n본 프로젝트는 체험단 신청자 선정 및 관리를 자동화하는 웹 SaaS 서비스이다. 구글폼으로 접수된 신청자의 SNS 영향력을 자동으로 검증하고, 선정/비선정자에게 맞춤형 메일을 자동 발송하여 체험단 운영 효율을 극대화한다. 핵심 가치는 운영 자동화, 정확한 영향력 검증, 브랜드별 통합 관리이다.\n\n## 2. 문제 정의(Problem Statement)\n- 체험단 신청자의 SNS 영향력을 수동으로 확인하는 데 과도한 시간 소요\n- 선정/비선정 안내 메일 발송이 지연되거나 누락되는 경우 발생\n- 여러 브랜드의 체험단을 동시 운영 시 관리 복잡도 증가\n- Google Apps Script 설정의 기술적 진입 장벽으로 인한 사용자 이탈\n\n## 3. 목표 및 목적(Goals and Objectives)\n- Primary Goal: 체험단 신청부터 선정, 안내까지 전 과정을 자동화한다.\n- Secondary Goals:\n  - 신청자 검증 시간 90% 단축\n  - 메일 발송 누락률 0% 달성\n  - 다중 브랜드 체험단 통합 관리\n- Success Metrics:\n  - 신청 후 선정 결과 처리 시간 ≤ 5분\n  - 메일 발송 성공률 ≥ 99.5%\n  - 브랜드당 월간 처리 가능 신청자 수 ≥ 10,000명\n\n## 4. 타깃 사용자(Target Audience)\n### Primary Users\n- 체험단을 운영하는 브랜드 마케터\n- 이커머스 사업자 및 스타트업\n- 마케팅 대행사\n- 니즈: 효율적인 체험단 관리, 자동화된 영향력 검증, 통합 대시보드\n\n### Secondary Users\n- 다중 브랜드 운영자\n- 체험단 전문 운영 업체\n\n## 5. 사용자 스토리(User Stories)\n- As a 마케터, I want 구글시트 링크만 입력해서 체험단 시스템을 즉시 구축하고 싶다.\n- As a 브랜드 담당자, I want SNS 영향력이 검증된 신청자만 자동으로 선정되길 원한다.\n- As a 운영자, I want 선정/비선정 메일이 자동으로 발송되어 CS 부담을 줄이고 싶다.\n- As a 관리자, I want 여러 브랜드의 체험단을 하나의 대시보드에서 관리하고 싶다.\n\n## 6. 기능 요구사항(Functional Requirements)\n### 핵심 기능(Core Features)\n1. 구글폼-구글시트 연동 체험단 신청 자동화\n   - 입력: 신청자가 작성한 구글폼 데이터(자동으로 구글시트에 입력), SNS 링크(네이버블로그, 인스타그램, 스레드 포함)\n   - 처리: 구글시트에서 신청 데이터 실시간 자동 수집, 신청자별 SNS 링크 데이터 파싱 및 저장\n   - Acceptance: 신규 신청 시 누락 없이 데이터 자동 반영, 구글시트 연동 성공률 100%\n\n2. SNS 영향력 자동 검증 및 체험단 선정\n   - 처리: 네이버 블로그(평균 방문자수 300명 이상), 인스타그램(팔로워 1,000명 이상), 스레드(팔로워 500명 이상) 자동 확인\n   - 선정 기준: 세 채널 중 한 곳이라도 기준을 충족하면 선정, 모두 미달시 비선정\n   - 결과 기록: 선정/비선정 결과를 구글시트에 자동 체크\n   - Acceptance: 선정/비선정 자동 체크, 오탐률 <1%, 구글시트 기록 누락률 0%\n\n3. 메일 자동 발송 시스템 (SaaS 자체 구현)\n   - 선정된 신청자: 선정일 기준 4일 후 선정 안내 메일 자동 발송\n   - 미선정자: 제품 또는 서비스 할인 쿠폰 링크가 포함된 미선정 안내 메일 자동 발송\n   - Acceptance: 메일 발송 오류율 <0.5%, 메일 발송 내역 대시보드에서 실시간 확인\n\n4. 브랜드별 체험단 대시보드 관리\n   - 각 브랜드(캠페인)별로 신청자 현황, 선정 현황, 메일 발송 현황, 효과 분석 등 대시보드 제공\n   - Acceptance: 브랜드별 데이터 분리, 실시간 상태 표시, 사용성 테스트 만족도 >90%\n\n5. 구글 로그인 및 구글시트 자동 연동\n   - SaaS 내 구글 로그인(OAuth2) 필수, 구글시트 링크 입력만으로 연동 자동화\n   - Acceptance: 로그인 후 바로 사용 가능, Google Apps Script 직접 입력 불필요\n\n6. 상세페이지 자동화(개발중)\n   - 입력: 제품 정보, 타깃 고객 페르소나(향후 지원 예정)\n   - 출력: 상세페이지 구성 요소(헤드라인, Benefit 등) 자동 생성(향후 제공)\n   - Acceptance: 개발 완료 후 별도 안내 예정\n\n### 지원 기능(Supporting Features)\n- 체험단 신청자 상세 내역 및 선정 여부 엑셀 다운로드/업로드\n- 이메일 발송 이력 및 상태 확인 기능\n- 체험단별(브랜드별) 진행 현황 및 효과 데이터 시각화\n- 다중 브랜드/캠페인 관리 기능\n- 관리자 알림(메일, 대시보드 내 실시간 알림)\n\n## 7. 비기능 요구사항(Non-Functional Requirements)\n- Performance: 평균 응답 ≤2초, 동시 신청자 처리 100명/분\n- Security: OAuth2, JWT, 개인정보 암호화, GDPR·개인정보보호법 준수\n- Usability: 초기 설정 <5분, 직관적 UI/UX\n- Scalability: 멀티테넌트 아키텍처, 브랜드별 독립 환경\n- Compatibility: Chrome, Safari, Edge 최신 2버전\n\n## 8. 기술 고려사항(Technical Considerations)\n- 아키텍처:\n  - Front: Next.js(React) + Tailwind CSS\n  - Back: Node.js + Express/Fastify\n  - DB: PostgreSQL(메인) + Redis(캐싱)\n  - 메일: SendGrid/AWS SES\n- 인프라: AWS/GCP, Docker, K8s\n- 통합: Google Sheets API, OAuth2, SNS 크롤링/API\n- 데이터 파이프라인: 실시간 동기화, 백그라운드 작업 큐\n- 모니터링: 메일 발송 상태, API 호출 로그, 에러 추적\n\n## 9. 성공 지표(KPIs)\n- 운영 효율: 신청자 처리 시간 90% 단축\n- 정확도: SNS 검증 정확도 99% 이상\n- 안정성: 시스템 가동률 99.9% 이상\n- 사용자 만족: NPS 60 이상\n- 비즈니스: 월간 활성 브랜드 수, 처리 신청자 수\n\n## 10. 일정 및 마일스톤(Timeline and Milestones)\n- Phase 1(4주): 구글시트 연동 및 데이터 수집\n- Phase 2(4주): SNS 영향력 자동 검증 시스템\n- Phase 3(3주): 메일 자동 발송 시스템\n- Phase 4(3주): 브랜드별 대시보드 구현\n- Phase 5(2주): 테스트 및 안정화\n- Phase 6(진행중): 상세페이지 자동화 개발\n\n## 11. 위험 및 대응(Risks and Mitigation)\n- SNS API 제한 → 크롤링 병행, 캐싱 전략\n- 메일 스팸 분류 → SPF/DKIM 설정, 발송량 점진적 증가\n- 구글시트 API 한계 → 배치 처리, 로컬 DB 동기화\n- 개인정보 보안 → 암호화, 접근 권한 관리, 로그 기록\n- 서비스 확장성 → 마이크로서비스 전환 준비\n\n## 12. 향후 고려사항(Future Considerations)\n- AI 기반 신청자 품질 평가 시스템\n- 추가 SNS 채널 지원(유튜브, 틱톡 등)\n- 체험단 성과 자동 추적 및 리포팅\n- 신청자 풀 관리 및 재활용 시스템\n- API 제공으로 외부 시스템 연동\n- 상세페이지 자동화 기능 완성 및 통합",
      "writedAt": "2025-07-28T10:29:57.947Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  웹 기반 SaaS 형태의 체험단 자동화 시스템.  \n  Frontend는 Next.js 기반 SPA, Backend는 Node.js(Express) 단일 서비스로 구현.  \n  Google Sheets API·OAuth2로 신청 데이터 수집, Redis 기반 큐로 배치 처리, SNS API/크롤링으로 영향력 검증, SendGrid(AWS SES)로 메일 발송.  \n- **핵심 기술 스택**  \n  Frontend: Next.js + Tailwind CSS  \n  Backend: Node.js + Express + Prisma ORM  \n  DB: PostgreSQL, Cache/Queue: Redis + Bull  \n  메일: SendGrid (AWS SES 대안)  \n  인프라: Docker, AWS(EKS/ECR) 또는 GCP(GKE) + Kubernetes  \n- **주요 기술 목표**  \n  ·평균 응답 시간 ≤ 2초  \n  ·동시 신청자 처리 100명/분 이상  \n  ·메일 발송 성공률 ≥ 99.5%  \n  ·시스템 가동률 ≥ 99.9%  \n- **핵심 가정**  \n  ·Google API 호출 할당량 충분  \n  ·SNS 크롤링 및 API 호출 지연 허용 범위 내  \n  ·단일 서비스로 시작 후 확장 필요시 마이크로서비스 전환 가능\n\n## 2. Tech Stack\n\n| Category        | Technology / Library       | Reasoning (선택 근거)                                       |\n| --------------- | -------------------------- | ----------------------------------------------------------- |\n| Frontend        | Next.js                    | SSR/SSG 지원으로 초기 로딩 및 SEO 최적화, React 생태계 활용 |\n| Styling         | Tailwind CSS               | 유연한 유틸리티 클래스, 빠른 UI 구현                        |\n| Backend         | Node.js + Express          | 가벼운 REST API 서버, 개발 생산성 및 커뮤니티 지원          |\n| ORM             | Prisma                     | 타입 안전성, 직관적 쿼리 빌더, 마이그레이션 지원           |\n| Database        | PostgreSQL                 | ACID 보장, JSONB 지원, 확장성                             |\n| Cache / Queue   | Redis + Bull               | 빠른 캐싱, 안정적 작업 큐 관리                             |\n| 메일 발송       | SendGrid (AWS SES)         | 신뢰도 높은 트랜잭션 메일, API 기반 대량 발송              |\n| 인증·인가       | OAuth2 (Google), JWT       | 구글 로그인 간편화, 토큰 기반 세션 관리                    |\n| SNS 검증        | Puppeteer / axios 크롤링   | 비공개 API 지원 시 헤드리스 브라우저 크롤링, API 호출 혼용 |\n| 인프라·배포     | Docker, Kubernetes (EKS/GKE)| 컨테이너화·오케스트레이션, 자동 확장 및 롤링 업데이트      |\n| 모니터링        | Prometheus + Grafana       | 메트릭 수집·시각화, 알림 설정 가능                         |\n| 로깅·추적       | ELK Stack (Elasticsearch, Kibana, Logstash) | 중앙 집중형 로그 관리 및 분석              |\n\n## 3. System Architecture Design\n\n### Top-Level 빌딩 블록\n- **Frontend (Next.js)**\n  - 페이지 라우팅, OAuth2 로그인, 대시보드 UI  \n- **Backend API (Express)**\n  - RESTful 엔드포인트, 인증·인가, 비즈니스 로직  \n- **Job Queue (Bull on Redis)**\n  - Google Sheets 동기화, SNS 검증, 메일 발송 작업 스케줄링  \n- **Database (PostgreSQL)**\n  - 신청자·결과·로그 등 주요 데이터 저장  \n- **Cache (Redis)**\n  - API 호출 속도 개선, 자격 검증 임시 저장  \n- **External Services**\n  - Google Sheets API, SNS 크롤링, SendGrid API  \n- **Infra & Monitoring**\n  - Kubernetes 클러스터, Prometheus·Grafana 모니터링, ELK 로깅  \n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[사용자(UI)] --> B[Next.js Frontend]\n    B --> C[Express Backend]\n    C --> D[PostgreSQL]\n    C --> E[Redis/Bull Queue]\n    E --> F[작업 Worker]\n    F --> G[Google Sheets API]\n    F --> H[SNS 크롤러/API]\n    F --> I[SendGrid API]\n    C --> J[Prometheus/Grafana]\n    C --> K[ELK Stack]\n```\n\n- 사용자(UI) → Next.js → Express API 요청  \n- Express → PostgreSQL/Redis로 데이터 저장 및 캐싱  \n- Express → Bull Queue에 백그라운드 작업 추가  \n- Worker → Google Sheets, SNS, SendGrid 외부 API 호출  \n- 시스템 메트릭 및 로그 → Prometheus/Grafana, ELK로 수집  \n\n### Code Organization & Convention\n\n**도메인 주도 설계(DDD) 전략**  \n- Domain Separation: `auth`, `sheet`, `snsValidation`, `mail`, `dashboard` 등  \n- Layer-Based Architecture:  \n  ·presentation (Controller)  \n  ·service (비즈니스 로직)  \n  ·repository (데이터 액세스)  \n  ·infrastructure (외부 API)  \n- Feature-Based Modules: 각 도메인별 폴더  \n- Shared Components: `utils`, `common`, `types`\n\n**파일·폴더 구조 예시**\n```\n/src\n├── auth\n│   ├── auth.controller.ts\n│   ├── auth.service.ts\n│   └── auth.repository.ts\n├── sheet\n│   ├── sheet.controller.ts\n│   ├── sheet.service.ts\n│   └── sheet.repository.ts\n├── snsValidation\n│   ├── sns.controller.ts\n│   ├── sns.service.ts\n│   └── sns.provider.ts\n├── mail\n│   ├── mail.controller.ts\n│   ├── mail.service.ts\n│   └── mail.provider.ts\n├── dashboard\n│   ├── dashboard.controller.ts\n│   └── dashboard.service.ts\n├── common\n│   ├── dto\n│   ├── filters\n│   ├── interceptors\n│   └── utils.ts\n├── config\n│   └── index.ts\n├── jobs\n│   ├── sheet.job.ts\n│   ├── sns.job.ts\n│   └── mail.job.ts\n├── prisma\n│   └── schema.prisma\n└── app.ts\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**  \n  RESTful JSON API, JWT 인증 헤더 사용  \n- **Database Interaction**  \n  Prisma ORM, connection pool 관리  \n- **External Service Integration**  \n  Google Sheets API (OAuth2 토큰 재사용), SNS 크롤링(Headless Chrome/Puppeteer + axios)  \n- **Background Job Processing**  \n  Bull 큐를 통한 작업 스케줄링 및 재시도 정책  \n- **데이터 동기화**  \n  주기적 배치(트리거 방식) + 실시간 웹훅 처리\n\n## 4. Performance & Optimization Strategy\n- Redis 캐싱 활용으로 빈번 요청 데이터 응답 속도 향상  \n- DB 인덱스 최적화 및 Prisma 쿼리 튜닝  \n- Bull 큐 동시 처리(worker concurrency) 조정  \n- HTTP Keep-Alive, Gzip 압축, CDN 활용으로 Frontend 정적 리소스 최적화  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP 구현, 4주)\n- Core Infrastructure: Docker · Kubernetes 클러스터 구성, CI/CD 파이프라인  \n- Essential Features: Google Sheets 연동, 신청 데이터 수집 모듈  \n- Basic Security: OAuth2 로그인, JWT 인증  \n- Development Setup: 코드베이스 구조, Prisma 마이그레이션  \n- Timeline: 4주\n\n### Phase 2: Feature Enhancement (기능 확장, 4주)\n- SNS 영향력 검증: 크롤링 및 API 연동 구현  \n- 메일 발송 시스템: Bull 스케줄러 + SendGrid 연동  \n- 대시보드 기본: 신청·선정 현황 조회 UI  \n- 보안 강화: HTTPS, CSP, 입력 검증  \n- Monitoring: Prometheus·Grafana·ELK 세팅  \n- Timeline: 4주\n\n### Phase 3: Scaling & Optimization (최적화·확장, 5주)\n- 멀티테넌트 지원: 브랜드별 DB 스키마 분리 또는 논리 분리  \n- 성능 튜닝: Auto-scaling, HPA 설정, Redis 클러스터링  \n- 고급 대시보드: 필터·차트·리포트  \n- 규제 준수: GDPR, 개인정보보호법 감사 로그  \n- Timeline: 5주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- 기술 리스크: SNS API 제한 → 크롤링 병행, 요청 레이트 리밋 준수  \n- 성능 리스크: 동시 처리 한계 → 큐 동시성 조정, 오토스케일링  \n- 보안 리스크: 토큰 탈취 → HTTPS, JWT 만료·리프레시 정책  \n- 통합 리스크: Google API 오류 → 재시도 및 백오프 로직, 로컬 동기화  \n\n### Project Delivery Risks\n- 일정 리스크: 외부 API 연동 지연 → 초기 프로토콜 스펙 확정, 대체 경로 확보  \n- 자원 리스크: 전문 인력 부족 → 외부 컨설팅, 온보딩 문서화  \n- 품질 리스크: 테스트 커버리지 부족 → E2E·단위 테스트 자동화  \n- 배포 리스크: 롤백 계획 부재 → 카나리 배포, Helm 차트 기반 버전 관리  \n- 비상 계획: 핵심 모듈 이슈 시 수동 운영 가이드 제공, 임시 백업·복구 절차 마련",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline Document: Automated Experience Group System\n\n## 1. Project Overview\n\nThis document outlines the coding standards and practices for the Automated Experience Group System, a web-based SaaS platform designed to automate the selection and management of experience group applicants. The system leverages Google Forms for data collection, performs automated SNS influence verification, and dispatches automated emails to selected and unselected applicants.\n\n**Key Architectural Decisions:**\n*   **Frontend:** Next.js with Tailwind CSS for optimized loading and responsive UI.\n*   **Backend:** Node.js with Express and Prisma ORM for a lightweight REST API server.\n*   **Database:** PostgreSQL for main data storage, Redis for caching and job queuing (Bull).\n*   **External Integrations:** Google Sheets API, SNS crawling (Puppeteer/Axios), SendGrid (or AWS SES) for email.\n*   **Infrastructure:** Docker and Kubernetes (AWS EKS/GKE) for containerization and orchestration.\n*   **Design Philosophy:** Domain-Driven Design (DDD) with a layered architecture to ensure modularity and separation of concerns.\n\n## 2. Core Principles\n\n1.  **Readability over Cleverness:** Code MUST be easily understood by any developer on the team.\n2.  **Modularity and Single Responsibility:** Each component, function, or module MUST have a single, clearly defined purpose.\n3.  **Testability and Maintainability:** Code MUST be designed to be easily tested and modified without introducing regressions.\n4.  **Performance and Scalability:** Solutions MUST consider performance implications and be designed for future scaling.\n5.  **Security by Design:** Security considerations MUST be integrated from the initial design phase.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. Frontend (Next.js, React, TypeScript)\n\n#### File Organization and Directory Structure\n\n*   **MUST:** Organize files by feature or domain, following a co-located approach.\n*   **MUST:** Use `pages`, `components`, `hooks`, `utils`, `types` directories at the root.\n*   **MUST:** Place component-specific styles (if not using Tailwind directly) within the component's directory.\n\n```\n// MUST: Feature-based organization\n/src\n├── pages\n│   ├── index.tsx\n│   └── dashboard\n│       └── [brandId].tsx\n├── components\n│   ├── common\n│   │   └── Button.tsx\n│   └── dashboard\n│       ├── BrandOverviewCard.tsx\n│       └── ApplicantTable.tsx\n├── hooks\n│   └── useAuth.ts\n├── utils\n│   └── api.ts\n├── types\n│   └── index.ts\n└── styles\n    └── globals.css\n```\n\n```\n// MUST NOT: Overly nested or generic structure\n/src\n├── views\n│   ├── Dashboard\n│   │   └── BrandPage.tsx\n├── shared\n│   ├── ui\n│   │   └── Button.tsx\n│   └── hooks\n│       └── useApi.ts\n```\n\n#### Import/Dependency Management\n\n*   **MUST:** Use absolute imports for modules within the `src` directory. Configure `tsconfig.json` for path aliases.\n*   **MUST:** Order imports: React/Next.js, external libraries, internal modules, relative imports (styles).\n*   **MUST:** Use named imports for specific exports, default imports for single exports.\n\n```typescript\n// MUST: Absolute imports and ordered\nimport React, { useState } from 'react';\nimport { useRouter } from 'next/router';\nimport axios from 'axios';\n\nimport { getBrandData } from '@/services/brandService';\nimport { Brand } from '@/types';\n\nimport BrandOverviewCard from '@/components/dashboard/BrandOverviewCard';\nimport styles from './DashboardPage.module.css'; // Example for module CSS\n```\n\n```typescript\n// MUST NOT: Relative imports for deep paths, unorganized\nimport BrandOverviewCard from '../../../components/dashboard/BrandOverviewCard';\nimport { useRouter } from 'next/router';\nimport React, { useState } from 'react';\nimport { Brand } from '../../types';\n```\n\n#### Error Handling Patterns\n\n*   **MUST:** Use `try-catch` blocks for asynchronous operations.\n*   **MUST:** Display user-friendly error messages in the UI.\n*   **MUST:** Log detailed errors to a centralized logging service (e.g., Sentry).\n\n```typescript\n// MUST: Robust error handling in components\nasync function fetchDashboardData() {\n  try {\n    const data = await getBrandData(brandId);\n    setBrandData(data);\n  } catch (error) {\n    console.error('Failed to fetch dashboard data:', error);\n    // Display error to user\n    alert('Failed to load dashboard data. Please try again.');\n    // Log to external service\n    // Sentry.captureException(error);\n  }\n}\n```\n\n### 3.2. Backend (Node.js, Express, TypeScript, Prisma)\n\n#### File Organization and Directory Structure\n\n*   **MUST:** Follow a Domain-Driven Design (DDD) approach with clear separation of concerns.\n*   **MUST:** Structure by domain (`auth`, `sheet`, `snsValidation`, `mail`, `dashboard`), each containing `controller`, `service`, `repository` (or `provider`) files.\n*   **MUST:** Place common utilities, DTOs, and middleware in a `common` directory.\n*   **MUST:** Separate job definitions into a `jobs` directory.\n\n```\n// MUST: Domain-driven and layered architecture\n/src\n├── auth\n│   ├── auth.controller.ts\n│   ├── auth.service.ts\n│   └── auth.repository.ts\n├── sheet\n│   ├── sheet.controller.ts\n│   ├── sheet.service.ts\n│   └── sheet.repository.ts\n├── snsValidation\n│   ├── sns.controller.ts\n│   ├── sns.service.ts\n│   └── sns.provider.ts // For external API/crawling logic\n├── mail\n│   ├── mail.controller.ts\n│   ├── mail.service.ts\n│   └── mail.provider.ts // For SendGrid integration\n├── common\n│   ├── dtos\n│   │   └── ApplicantDto.ts\n│   ├── middleware\n│   │   └── authMiddleware.ts\n│   └── utils\n│       └── pagination.ts\n├── config\n│   └── index.ts\n├── jobs\n│   ├── sheetSyncJob.ts\n│   └── mailDispatchJob.ts\n├── prisma\n│   └── schema.prisma\n└── app.ts // Entry point\n```\n\n```\n// MUST NOT: Monolithic or flat structure\n/src\n├── controllers\n│   ├── authController.ts\n│   └── dataController.ts\n├── services\n│   ├── authService.ts\n│   └── dataService.ts\n├── models\n│   ├── User.ts\n│   └── Applicant.ts\n├── routes.ts\n└── server.ts\n```\n\n#### Import/Dependency Management\n\n*   **MUST:** Use absolute imports configured via `tsconfig.json` paths.\n*   **MUST:** Order imports: Node.js built-ins, external libraries, internal modules.\n*   **MUST:** Inject dependencies (e.g., services into controllers, repositories into services) rather than direct instantiation for testability.\n\n```typescript\n// MUST: Absolute imports and dependency injection\nimport { Request, Response, NextFunction } from 'express';\nimport { PrismaClient } from '@prisma/client';\n\nimport { AuthService } from '@/auth/auth.service';\nimport { UserLoginDto } from '@/common/dtos/UserLoginDto';\nimport { AppError } from '@/common/errors/AppError';\n\nexport class AuthController {\n  constructor(private authService: AuthService) {} // Dependency injection\n\n  async login(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { email, password } = req.body as UserLoginDto;\n      const token = await this.authService.authenticate(email, password);\n      res.json({ token });\n    } catch (error) {\n      next(error); // Pass to error handling middleware\n    }\n  }\n}\n```\n\n#### Error Handling Patterns\n\n*   **MUST:** Centralize error handling using Express middleware.\n*   **MUST:** Define custom error classes for specific application errors (e.g., `NotFoundError`, `ValidationError`).\n*   **MUST:** Return consistent JSON error responses to the client.\n*   **MUST:** Log all unhandled exceptions and critical errors.\n\n```typescript\n// MUST: Custom error class\nclass AppError extends Error {\n  statusCode: number;\n  isOperational: boolean;\n\n  constructor(message: string, statusCode: number = 500) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true; // Mark as expected error\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// MUST: Centralized error handling middleware\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      status: 'error',\n      message: err.message,\n    });\n  }\n\n  console.error('UNHANDLED ERROR:', err); // Log unexpected errors\n  return res.status(500).json({\n    status: 'error',\n    message: 'Something went wrong!',\n  });\n});\n\n// MUST NOT: Catching and sending different error responses everywhere\n// In a controller:\n// try { ... } catch (error) { res.status(400).json({ message: error.message }); }\n// This leads to inconsistent error responses.\n```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Consistent Naming Conventions:**\n    *   **Rationale:** Improves readability and predictability.\n    *   **Rule:**\n        *   Variables and functions: `camelCase` (e.g., `applicantCount`, `processSheetData`).\n        *   Classes and types: `PascalCase` (e.g., `ApplicantService`, `UserDto`).\n        *   Constants: `SCREAMING_SNAKE_CASE` (e.g., `MAX_RETRIES`, `DEFAULT_TIMEOUT`).\n        *   Files: `kebab-case` for directories and `kebab-case.ts` for files (e.g., `sns-validation.service.ts`).\n*   **Strict Type Usage (TypeScript):**\n    *   **Rationale:** Enhances code reliability, enables better tooling, and reduces runtime errors.\n    *   **Rule:** Explicitly define types for function parameters, return values, and complex variables. Avoid `any` unless absolutely necessary (e.g., during rapid prototyping or for highly dynamic data, with a comment explaining the rationale).\n*   **Meaningful Variable and Function Names:**\n    *   **Rationale:** Self-documenting code reduces the need for extensive comments.\n    *   **Rule:** Names MUST clearly indicate their purpose or the data they hold.\n    *   ```typescript\n        // MUST: Meaningful names\n        const selectedApplicants: Applicant[] = [];\n        function validateSnsInfluence(profileUrl: string): Promise<boolean> { /* ... */ }\n        ```\n    *   ```typescript\n        // MUST NOT: Ambiguous names\n        const arr = []; // What does 'arr' hold?\n        function process(data: any) { /* ... */ } // What is being processed?\n        ```\n*   **Concise Functions and Methods:**\n    *   **Rationale:** Improves readability, testability, and reduces complexity.\n    *   **Rule:** Functions/methods MUST ideally do one thing and do it well. Keep them short (e.g., under 50 lines of code, excluding comments/empty lines).\n*   **Use `async/await` for Asynchronous Operations:**\n    *   **Rationale:** Simplifies asynchronous code, making it more readable and easier to debug than traditional Promise chains.\n    *   **Rule:** Always use `async/await` for Promise-based operations.\n    *   ```typescript\n        // MUST: Use async/await\n        async function fetchUserData(userId: string) {\n          try {\n            const user = await userRepository.findById(userId);\n            return user;\n          } catch (error) {\n            console.error('Error fetching user:', error);\n            throw new AppError('User not found', 404);\n          }\n        }\n        ```\n    *   ```typescript\n        // MUST NOT: Chained .then/.catch where async/await is clearer\n        function fetchUserData(userId: string) {\n          return userRepository.findById(userId)\n            .then(user => user)\n            .catch(error => {\n              console.error('Error fetching user:', error);\n              throw new AppError('User not found', 404);\n            });\n        }\n        ```\n*   **Consistent Code Formatting:**\n    *   **Rationale:** Maintains a uniform appearance across the codebase, reducing cognitive load.\n    *   **Rule:** Use Prettier and ESLint with a shared configuration. Configure IDEs to format on save.\n        *   Indentation: 2 spaces.\n        *   Quotes: Single quotes (`'`).\n        *   Semicolons: Always use.\n        *   Trailing commas: `es5`.\n\n### MUST NOT Do:\n\n*   **Making Huge, Multi-Responsibility Modules in a Single File:**\n    *   **Rationale:** Violates the Single Responsibility Principle, leading to tightly coupled, hard-to-maintain, and untestable code.\n    *   **Avoid:** A single file containing multiple unrelated controllers, services, and repository logic.\n    *   ```typescript\n        // MUST NOT: Monolithic file\n        // user.ts\n        // Contains User model, User CRUD service, User authentication logic, and User API routes.\n        class UserService { /* ... */ }\n        class UserController { /* ... */ }\n        function authenticateUser() { /* ... */ }\n        // ... and more\n        ```\n*   **Define Complex State Management Patterns Arbitrarily:**\n    *   **Rationale:** Introduces unnecessary complexity and boilerplate, especially for a project of this scale.\n    *   **Avoid:** Implementing custom, overly abstract state management solutions (e.g., a bespoke Redux-like store) when simpler solutions (React Context, Zustand/Jotai for local/global state) suffice.\n*   **Common Mistakes in the Specific Tech Stack:**\n    *   **Backend (Node.js/Express):**\n        *   **MUST NOT:** Block the event loop with synchronous I/O operations or CPU-intensive tasks. Use asynchronous alternatives.\n        *   **MUST NOT:** Directly expose database models or ORM instances to controllers. Always use a service layer.\n        *   **MUST NOT:** Hardcode sensitive information (API keys, secrets). Use environment variables.\n    *   **Frontend (Next.js/React):**\n        *   **MUST NOT:** Mutate state directly. Always use state setter functions or immutability helpers.\n        *   **MUST NOT:** Forget `key` props when rendering lists of components.\n        *   **MUST NOT:** Perform heavy computations directly in render functions; use `useMemo` or `useCallback` when necessary.\n    *   **Prisma:**\n        *   **MUST NOT:** Directly access `PrismaClient` instances in controllers or frontend code. Encapsulate database operations within repository classes.\n        *   **MUST NOT:** Neglect proper error handling for database operations.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n*   **Layered Architecture (Backend):**\n    *   **Presentation Layer (Controllers):** Handles HTTP requests, input validation, and delegates to the service layer. MUST NOT contain business logic.\n    *   **Service Layer (Services):** Contains core business logic, orchestrates operations across multiple repositories, and applies domain rules.\n    *   **Data Access Layer (Repositories):** Abstracts database interactions. Responsible for CRUD operations on a single entity or aggregate. MUST NOT contain business logic.\n    *   **Infrastructure Layer (Providers):** Handles external integrations (e.g., Google Sheets API, SendGrid API, SNS crawlers).\n\n```typescript\n// MUST: Clear separation of concerns (Backend)\n// In auth.controller.ts\nclass AuthController {\n  constructor(private authService: AuthService) {} // Dependency injection\n  async login(req: Request, res: Response) { /* ... */ } // Delegates to service\n}\n\n// In auth.service.ts\nclass AuthService {\n  constructor(private authRepository: AuthRepository) {} // Dependency injection\n  async authenticate(email: string, passwordHash: string) {\n    const user = await this.authRepository.findByEmail(email); // Uses repository\n    // ... business logic ...\n  }\n}\n\n// In auth.repository.ts\nclass AuthRepository {\n  constructor(private prisma: PrismaClient) {}\n  async findByEmail(email: string) {\n    return this.prisma.user.findUnique({ where: { email } }); // Direct DB interaction\n  }\n}\n```\n\n### Data Flow Patterns\n\n*   **Request-Response Cycle:**\n    *   **MUST:** Frontend sends RESTful JSON requests to the Backend API.\n    *   **MUST:** Backend processes requests, interacts with DB/services, and sends JSON responses.\n*   **Asynchronous Job Processing:**\n    *   **MUST:** Use Bull (on Redis) for background tasks (e.g., Google Sheet synchronization, SNS validation, email dispatch).\n    *   **MUST:** Controllers MUST enqueue jobs and return immediate responses to the client, rather than waiting for long-running tasks to complete.\n    *   ```typescript\n        // MUST: Enqueue job for background processing\n        // In sheet.controller.ts\n        async function triggerSheetSync(req: Request, res: Response) {\n          const { sheetId } = req.body;\n          await sheetSyncQueue.add('sync-sheet', { sheetId }); // Add job to queue\n          res.status(202).json({ message: 'Sheet synchronization initiated.' }); // Respond immediately\n        }\n        ```\n    *   ```typescript\n        // MUST NOT: Blocking operation\n        // In sheet.controller.ts\n        async function triggerSheetSync(req: Request, res: Response) {\n          const { sheetId } = req.body;\n          await sheetService.syncSheet(sheetId); // Direct call, blocks response\n          res.status(200).json({ message: 'Sheet synchronization completed.' });\n        }\n        ```\n\n### State Management Conventions (Frontend)\n\n*   **MUST:** Use React's `useState` and `useReducer` for local component state.\n*   **MUST:** Use React Context API for global state that is shared across many components but doesn't change frequently (e.g., authentication status, user preferences).\n*   **MUST:** For complex, frequently updated global state, consider a lightweight library like Zustand or Jotai. Avoid Redux unless project complexity explicitly demands it.\n\n### API Design Standards (Backend)\n\n*   **RESTful Principles:**\n    *   **MUST:** Use meaningful, plural resource names in URLs (e.g., `/api/applicants`, `/api/brands`).\n    *   **MUST:** Use standard HTTP methods (GET, POST, PUT, DELETE) for corresponding CRUD operations.\n    *   **MUST:** Use appropriate HTTP status codes (e.g., 200 OK, 201 Created, 202 Accepted, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error).\n*   **Data Transfer Objects (DTOs):**\n    *   **MUST:** Define DTOs for request bodies and response payloads to ensure clear data contracts and validation.\n    *   ```typescript\n        // MUST: Use DTOs for request validation and clear contracts\n        // In common/dtos/CreateApplicantDto.ts\n        export class CreateApplicantDto {\n          @IsString()\n          @IsNotEmpty()\n          name: string;\n\n          @IsUrl()\n          snsLink: string;\n\n          @IsEmail()\n          email: string;\n        }\n\n        // In applicant.controller.ts\n        async createApplicant(req: Request, res: Response) {\n          const applicantData: CreateApplicantDto = req.body;\n          // Validate applicantData using a validation library (e.g., class-validator)\n          // ...\n        }\n        ```\n*   **Versioning:**\n    *   **MUST:** Implement API versioning (e.g., `/api/v1/applicants`) to allow for backward compatibility.\n*   **Authentication and Authorization:**\n    *   **MUST:** Use JWT for token-based authentication.\n    *   **MUST:** Implement middleware for route protection and role-based access control.",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-28T10:29:57.949Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-07-28T10:29:57.949Z"
    }
  ]
}
{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 개요(Executive Summary)\n본 프로젝트는 생성형 AI를 활용해 SEO 기반 글쓰기, SNS 콘텐츠 기획, 상세페이지 기획을 자동화·간소화하는 웹/앱 서비스이다. 콘텐츠 마케팅 리소스가 부족한 1인‧소규모 사업자가 혼자서도 전문적인 마케팅 콘텐츠를 제작·관리하도록 돕는다. 핵심 가치는 비용 절감, 제작 속도 향상, 퀄리티 균일화이다.\n\n## 2. 문제 정의(Problem Statement)\n- 소규모 사업자는 마케팅 예산·인력이 부족해 전문 콘텐츠 제작이 어렵다.\n- 외주 대행사는 비용이 높고 커뮤니케이션 비용이 크다.\n- 기존 도구는 개별 기능만 제공하거나 복잡해 학습 곡선이 높다.\n- AI 기반 자동화 도구 부재로 시간과 비용이 과다 소모된다.\n\n## 3. 목표 및 목적(Goals and Objectives)\n- Primary Goal: 누구나 쉽고 빠르게 다양한 마케팅 콘텐츠를 생성할 수 있게 한다.\n- Secondary Goals:\n  - 제작 시간 70% 단축\n  - 콘텐츠 제작 비용 60% 절감\n  - 사용자 월간 활성률(MAU) 40% 이상 유지\n- Success Metrics:\n  - 콘텐츠 생성 완료 건수/사용자/월 ≥ 10\n  - 평균 생성 소요 시간 ≤ 3분\n  - NPS ≥ 50\n\n## 4. 타깃 사용자(Target Audience)\n### Primary Users\n- 1인‧소규모 온라인 사업자(25~45세)\n- 스타트업 마케터, 프리랜서 셀러\n- 니즈: 빠르고 저렴한 콘텐츠 제작, SEO 최적화, 다양한 포맷 지원\n### Secondary Users\n- 마케팅 대행사(서포트 도구), 교육기관(실습용), VC·엑셀러레이터(포트폴리오 관리)\n\n## 5. 사용자 스토리(User Stories)\n- As a 소상공인, I want AI에게 키워드만 입력해 SEO 글을 받아 시간을 절약하고 싶다.\n- As a 마케터, I want SNS 주제 캘린더를 자동 제안받아 캠페인 기획을 빠르게 끝내고 싶다.\n- As an 이커머스 셀러, I want 상세페이지 요소(헤드라인, USP, 이미지 가이드)를 자동 생성해 전환율을 높이고 싶다.\n- As a 사용자, I want 내 브랜드 정보(톤, 키워드)를 저장해 일관된 결과를 받고 싶다.\n\n## 6. 기능 요구사항(Functional Requirements)\n### 핵심 기능(Core Features)\n1. SEO 기반 글쓰기 자동화  \n   - 입력: 키워드·분야·톤  \n   - 출력: 제목, 목차, 본문(>1,000자), 메타 설명  \n   - Acceptance: SEO 점수 >80/100, 키워드 포함률 ≥2%, 생성 ≤60초\n\n2. SNS 콘텐츠 기획  \n   - 입력: 캠페인 목표, 기간, 대상 SNS  \n   - 출력: 30일 캘린더, 게시물별 카피·해시태그·이미지 프롬프트  \n   - Acceptance: 중복 해시태그 <10%, 톤 & 브랜드 가이드 반영률 90%\n\n3. 상세페이지 기획  \n   - 입력: 제품 특징, 고객 페르소나  \n   - 출력: 헤드라인, 핵심 Benefit 5개, FAQ, 이미지 콘셉트  \n   - Acceptance: USP 포함률 100%, 가독성 점수 >70(Flesch-Kincaid)\n\n### 지원 기능(Supporting Features)\n- 브랜드/톤/키워드 “나만의 정보” 저장·불러오기\n- 콘텐츠 버전·히스토리 관리 및 즐겨찾기\n- 워크스페이스 협업(공동 편집, 댓글)\n- 내보내기: PDF, DOCX, HTML, SNS API 바로 업로드\n- 대시보드: 생성 횟수, 퍼포먼스, SEO 점수 분석\n\n## 7. 비기능 요구사항(Non-Functional Requirements)\n- Performance: 평균 응답 ≤2초, 동시요청 1,000 RPS\n- Security: OAuth2, JWT, AES-256 저장 암호화, GDPR·개인정보보호법 준수\n- Usability: Onboarding <3min, UX 연구 기반 NNG 수준\n- Scalability: 멀티테넌트, 마이크로서비스, 오토스케일링(K8s)\n- Compatibility: Chrome, Safari, Edge 최신 2버전 / iOS 14+, Android 11+\n\n## 8. 기술 고려사항(Technical Considerations)\n- 아키텍처:  \n  - Front: Next.js(React) + Tailwind;  \n  - Mobile: React Native → Expo 빌드;  \n  - Back: Node.js(BFF) + Python FastAPI(AI 서비스);  \n  - AI: OpenAI GPT-4/3.5-turbo + 자체 파인튜닝 모델;  \n  - DB: PostgreSQL(서비스) + Redis(세션) + S3(콘텐츠 저장)\n- 인프라: AWS (EKS, Lambda for webhooks), CDN(CloudFront)\n- 통합: GPT API, SNS Graph API(Facebook, Instagram, LinkedIn, X), Google Analytics\n- 데이터 파이프라인: 로그→Kinesis→Redshift→Metabase\n- 장애대응: Circuit Breaker, Rate Limiter, Retry Queue\n\n## 9. 성공 지표(KPIs)\n- 사용자 지표: MAU, DAU/MAU≥25%, retention D30≥40%\n- 비즈니스 지표: 유료 전환율 8%+, ARPU $30+\n- 기술 지표: 500 오류율 <0.1%, 평균 응답 95p ≤1.5s\n\n## 10. 일정 및 마일스톤(Timeline and Milestones)\n- Phase 0(4주): 요구사항 확정, UX 리서치, UI 와이어프레임\n- Phase 1 MVP(8주): 계정·SEO 글쓰기·브랜드 저장, Web only\n- Phase 2 Beta(6주): SNS 기획, 상세페이지, 모바일 앱 알파\n- Phase 3 GA(8주): 협업, 대시보드, 다국어, 모바일 GA\n- Phase 4 Growth(지속): AI 파인튜닝, 마켓플레이스 연동, 엔터프라이즈 기능\n\n## 11. 위험 및 대응(Risks and Mitigation)\n- AI 결과품질 편차 → 커스텀 프롬프트·파인튜닝·Human-in-the-loop\n- API 비용 급증 → 캐싱·로컬 모델 병행, 사용량 기반 요금제\n- 개인정보 노출 → 민감정보 필터링, 프라이버시 게이트\n- 사용자 유입 저조 → 무료 크레딧 제공, 파트너십 마케팅\n- 법적 규제 변화 → 법무 리뷰 주기, 약관·삭제 프로세스 업데이트\n\n## 12. 향후 고려사항(Future Considerations)\n- 영상·이미지 생성 AI 통합(멀티모달)\n- 마켓플레이스(템플릿, 프롬프트) 구축\n- AI 성과 최적화 추천(AB 테스트 자동화)\n- Open API로 SaaS·CMS 연동\n- 엔터프라이즈 SSO, 팀별 Role 관리, SLA 제공",
      "writedAt": "2025-07-24T21:47:11.784Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 개요 기술 요약\n\n### 프로젝트 개요\n본 문서는 생성형 AI를 활용한 마케팅 콘텐츠 자동화 웹 서비스의 기술적 요구사항을 정의합니다. 프로젝트의 핵심 목표는 1인 사업자 및 소규모 마케터가 최소한의 노력으로 SEO 블로그 글, SNS 콘텐츠 등을 생성할 수 있는 플랫폼을 신속하게 구축하는 것입니다. 초기 단계에서는 시장의 빠른 진입을 위해 핵심 기능인 'AI 글쓰기'에 집중하며, 안정적이고 확장 가능한 기반을 마련하는 데 중점을 둡니다. 아키텍처는 MVP(최소 기능 제품)의 즉시 출시를 위해 단순화된 단일 백엔드 구조로 시작하며, 서비스 성장에 따라 점진적으로 고도화할 계획입니다.\n\n### 핵심 기술 스택\n- **프론트엔드**: Next.js (React), Tailwind CSS\n- **백엔드**: Python (FastAPI)\n- **데이터베이스**: PostgreSQL (주요 데이터), Redis (캐싱/세션), Amazon S3 (콘텐츠 저장)\n- **AI 및 외부 연동**: Google Gemini API, Naver 검색어 트렌드 API, 소셜 로그인(OAuth 2.0)\n- **인프라**: AWS App Runner (백엔드/프론트엔드 배포), Amazon RDS (PostgreSQL), Amazon ElastiCache (Redis)\n\n### 주요 기술 목표\n- **신속한 MVP 출시**: 8주 내에 로그인 및 핵심 글쓰기 기능을 포함한 MVP 버전 출시\n- **안정적인 AI 연동**: Gemini 및 Naver API와의 안정적인 연동을 통해 일관된 품질의 콘텐츠 생성 보장\n- **사용자 경험 최적화**: 실시간 글자 수 계산, 즉각적인 복사 기능 등 직관적이고 빠른 사용자 인터페이스 제공\n- **확장성 기반 마련**: 향후 기능 추가 및 사용자 증가에 유연하게 대응할 수 있는 단순하고 명확한 코드 구조 설계\n\n### 핵심 기술 가정\n- 초기 사용자 트래픽은 복잡한 오토스케일링(예: Kubernetes) 없이 AWS App Runner의 기본 스케일링 기능으로 충분히 감당 가능하다고 가정합니다.\n- 외부 API(Gemini, Naver)의 응답 속도 및 안정성이 서비스 전체 성능에 직접적인 영향을 미치므로, 이에 대한 예외 처리 및 비동기 처리가 필수적입니다.\n- MVP 단계에서는 복잡한 데이터 분석 파이프라인(Kinesis, Redshift) 대신 기본적인 로그 수집 및 분석(CloudWatch)으로 충분합니다.\n\n## 2. 기술 스택\n\n| 범주 | 기술 / 라이브러리 | 선정 사유 |\n| --- | --- | --- |\n| **프론트엔드** | Next.js (React) | 요구사항에 명시됨. SEO 최적화에 유리하며, 서버 사이드 렌더링(SSR)을 통해 초기 로딩 성능을 개선할 수 있음. |\n| | Tailwind CSS | 요구사항에 명시됨. 유틸리티 기반 스타일링으로 신속한 UI 개발 및 일관된 디자인 시스템 적용에 용이함. |\n| **백엔드** | Python (FastAPI) | 요구사항에 명시됨. AI/ML 연동에 강점을 가지며, 비동기 처리를 지원하여 외부 API 호출이 많은 서비스에 적합. 개발 생산성이 높음. |\n| **데이터베이스** | PostgreSQL | 요구사항에 명시됨. 정형 데이터(사용자 정보, 콘텐츠 메타데이터)를 안정적으로 관리하기 위한 관계형 데이터베이스. |\n| | Redis | 요구사항에 명시됨. 외부 API 응답 결과 캐싱, 사용자 세션 관리 등을 통해 시스템 전반의 응답 속도를 향상시키기 위함. |\n| | Amazon S3 | 요구사항에 명시됨. 생성된 글(HTML, TEXT) 및 관련 미디어 파일을 비용 효율적으로 저장하고 관리하기 위함. |\n| **AI 모델** | Google Gemini API (gemini-2.5-pro) | 요구사항에 명시됨. 핵심 기능인 제목 및 본문 생성에 사용. 최신 모델을 활용하여 고품질의 결과물 도출. |\n| **인프라/배포** | AWS App Runner | 컨테이너 기반 애플리케이션을 가장 빠르고 간단하게 배포 및 확장할 수 있는 관리형 서비스. MVP의 신속한 배포 목표에 부합. |\n| **외부 연동** | Naver 검색어 트렌드 API | 요구사항에 명시됨. 사용자에게 연관 키워드를 추천하여 콘텐츠의 SEO 품질을 높이는 데 활용. |\n| | OAuth 2.0 (소셜 로그인) | 사용자의 가입 및 로그인 허들을 낮추기 위한 표준 프로토콜. Google, Kakao 등 주요 플랫폼 연동. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **프론트엔드 (웹 애플리케이션)**: Next.js로 구축된 단일 페이지 애플리케이션(SPA). 사용자와의 모든 상호작용을 처리하며, AWS의 CDN(CloudFront)을 통해 전역 사용자에게 빠르게 제공됩니다.\n  - 하위 구성 요소: UI 컴포넌트, 상태 관리, API 클라이언트, 라우팅\n- **백엔드 API 서버**: Python FastAPI로 구현된 단일(Monolithic) API 서버. 사용자 인증, 비즈니스 로직 처리, 데이터베이스 연동 및 외부 AI/데이터 API 호출을 총괄합니다.\n  - 하위 구성 요소: API 엔드포인트, 비즈니스 로직 서비스, 데이터베이스 접근 계층(ORM), 외부 API 연동 모듈\n- **데이터 스토어**: 서비스의 데이터를 저장하고 관리하는 구성 요소 집합입니다.\n  - 하위 구성 요소: Amazon RDS for PostgreSQL (영구 데이터), Amazon ElastiCache for Redis (임시/캐시 데이터), Amazon S3 (파일 객체)\n- **외부 서비스**: 서비스의 핵심 기능을 위해 연동되는 제3자 API입니다.\n  - 하위 구성 요소: Google Gemini API, Naver API, 소셜 로그인 제공자(IdP)\n\n### 최상위 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    subgraph \"사용자 환경\"\n        A[사용자 브라우저]\n    end\n\n    subgraph \"AWS 클라우드\"\n        B[프론트엔드 (Next.js on App Runner/CloudFront)]\n        C[백엔드 API (FastAPI on App Runner)]\n        D[데이터베이스 (PostgreSQL on RDS)]\n        E[캐시 (Redis on ElastiCache)]\n        F[파일 스토리지 (S3)]\n    end\n\n    subgraph \"외부 서비스\"\n        G[Google Gemini API]\n        H[Naver API]\n        I[소셜 로그인 제공자]\n    end\n\n    A -- HTTPS --> B\n    B -- API 요청 --> C\n    C -- 인증 요청 --> I\n    C -- DB 쿼리 --> D\n    C -- 캐시 조회/저장 --> E\n    C -- 파일 업로드/다운로드 --> F\n    C -- AI 생성 요청 --> G\n    C -- 키워드 추천 요청 --> H\n```\n\n- **사용자 요청 처리**: 사용자는 브라우저를 통해 프론트엔드 애플리케이션에 접속합니다. 프론트엔드는 정적 콘텐츠를 제공하고 API 서버에 데이터(예: 글 생성 요청)를 보냅니다.\n- **백엔드 로직 수행**: 백엔드 API 서버는 사용자 요청을 받아 인증(소셜 로그인)을 처리하고, 비즈니스 로직을 수행합니다. 글 생성 요청 시, Gemini API와 Naver API를 호출하여 필요한 데이터를 조합합니다.\n- **데이터 관리**: 사용자 정보, 생성된 콘텐츠의 메타데이터 등은 PostgreSQL에 저장됩니다. 자주 사용되거나 생성 비용이 높은 데이터(예: API 응답)는 Redis에 캐싱하여 성능을 최적화합니다. 생성된 글의 원본 파일은 S3에 저장됩니다.\n- **외부 API 연동**: 백엔드는 핵심 기능 구현을 위해 외부 서비스(Gemini, Naver)와 통신하며, 이 과정에서 발생할 수 있는 지연은 비동기 방식으로 처리하여 사용자 경험 저하를 최소화합니다.\n\n### 코드 구조 및 컨벤션\n**도메인 주도 구성 전략**\n- **도메인 분리**: 비즈니스 도메인(예: 사용자 관리, 글쓰기, 인증)을 기준으로 코드를 구성하여 응집도를 높이고 결합도를 낮춥니다.\n- **계층 기반 아키텍처**: 각 도메인 내에서는 프레젠테이션(API 엔드포인트), 비즈니스 로직(서비스), 데이터 접근(리포지토리) 계층으로 명확히 분리합니다.\n- **기능 기반 모듈**: 특정 기능과 관련된 파일(예: 라우트, 서비스, 모델)을 하나의 폴더에 그룹화하여 관련 코드 파악을 용이하게 합니다.\n- **공유 컴포넌트**: 공통 유틸리티, 설정, 타입 정의 등은 전용 공유 모듈에 배치하여 중복을 제거합니다.\n\n**범용 파일 및 폴더 구조 (백엔드 FastAPI 기준)**\n```\n/\n├── app/\n│   ├── __init__.py\n│   ├── main.py             # FastAPI 앱 초기화 및 미들웨어 설정\n│   ├── core/               # 프로젝트 핵심 설정\n│   │   ├── __init__.py\n│   │   └── config.py       # 환경 변수, 설정 값 관리\n│   ├── db/                 # 데이터베이스 연결 및 세션 관리\n│   │   ├── __init__.py\n│   │   └── session.py\n│   ├── domains/            # 비즈니스 도메인별 모듈\n│   │   ├── __init__.py\n│   │   ├── auth/           # 인증 및 사용자 관리 도메인\n│   │   │   ├── __init__.py\n│   │   │   ├── auth_router.py\n│   │   │   ├── auth_service.py\n│   ",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "guideline",
      "content": "# 코드 가이드라인 문서\n\n## 1. 프로젝트 개요\n\n본 프로젝트는 생성형 AI를 활용하여 SEO 기반 글쓰기, SNS 콘텐츠 기획, 상세페이지 기획을 자동화하는 웹/앱 서비스입니다. 1인 및 소규모 사업자가 전문적인 마케팅 콘텐츠를 효율적으로 제작할 수 있도록 돕는 것을 목표로 합니다.\n\nTRD에 명시된 주요 기술 스택 및 아키텍처는 다음과 같습니다:\n\n*   **프론트엔드**: Next.js (React), Tailwind CSS\n*   **백엔드**: Python (FastAPI)\n*   **데이터베이스**: PostgreSQL, Redis, Amazon S3\n*   **AI 및 외부 연동**: Google Gemini API, Naver 검색어 트렌드 API, OAuth 2.0\n*   **인프라**: AWS App Runner, Amazon RDS, Amazon ElastiCache\n\n아키텍처는 MVP의 신속한 출시를 위해 단일(Monolithic) 백엔드 구조로 시작하며, 향후 서비스 성장에 따라 점진적으로 마이크로서비스 아키텍처로 전환될 수 있음을 고려하여 설계되었습니다.\n\n## 2. 핵심 원칙\n\n*   **가독성**: 모든 코드는 명확하고 이해하기 쉬워야 합니다.\n*   **유지보수성**: 변경 및 확장이 용이하도록 모듈화되고 일관성 있게 작성되어야 합니다.\n*   **성능**: 효율적인 알고리즘과 최적화된 리소스 사용을 통해 서비스의 응답 속도를 보장해야 합니다.\n*   **안정성**: 예외 처리 및 견고한 설계를 통해 오류 발생 가능성을 최소화해야 합니다.\n*   **보안**: 민감 정보 처리 및 외부 연동 시 보안 취약점을 최소화해야 합니다.\n\n## 3. 언어별 가이드라인\n\n### 3.1. 백엔드 (Python / FastAPI)\n\n#### 3.1.1. 파일 구성 및 디렉토리 구조\n\nTRD에 명시된 도메인 주도 구성 전략을 따릅니다.\n\n```\n/app\n├── main.py             # FastAPI 앱 초기화 및 미들웨어 설정\n├── core/               # 핵심 설정 및 유틸리티\n│   ├── config.py       # 환경 변수, 설정 값\n│   └── security.py     # 인증 및 보안 관련 유틸리티\n├── db/                 # 데이터베이스 연결 및 세션 관리\n│   ├── database.py     # SQLAlchemy 엔진, 세션 생성\n│   └── base.py         # SQLAlchemy 선언적 기본 클래스\n├── domains/            # 비즈니스 도메인별 모듈\n│   ├── auth/           # 인증 및 사용자 관리\n│   │   ├── router.py   # FastAPI 라우터 (API 엔드포인트)\n│   │   ├── service.py  # 비즈니스 로직\n│   │   ├── crud.py     # 데이터베이스 CRUD 작업 (선택 사항, 리포지토리 패턴 권장)\n│   │   ├── models.py   # SQLAlchemy 모델 (DB 스키마)\n│   │   ├── schemas.py  # Pydantic 스키마 (요청/응답 유효성 검사)\n│   │   └── dependencies.py # 의존성 주입\n│   ├── content/        # 콘텐츠 생성 및 관리\n│   │   ├── router.py\n│   │   ├── service.py\n│   │   ├── models.py\n│   │   └── schemas.py\n│   └── ...\n├── external/           # 외부 API 연동 모듈\n│   ├── gemini_api.py\n│   ├── naver_api.py\n│   └── ...\n├── utils/              # 공통 유틸리티 함수\n│   ├── __init__.py\n│   └── helpers.py\n└── tests/              # 테스트 코드\n```\n\n*   **MUST**: 각 도메인(예: `auth`, `content`)은 `router.py`, `service.py`, `models.py`, `schemas.py` 등으로 구성하여 책임 분리를 명확히 합니다.\n*   **MUST**: `schemas.py` 파일은 Pydantic 모델을 정의하여 API 요청/응답의 유효성을 검사하고 문서화합니다.\n*   **MUST**: `service.py` 파일은 비즈니스 로직을 포함하며, `crud.py` 또는 리포지토리 패턴을 통해 데이터베이스와 상호작용합니다.\n*   **MUST NOT**: 단일 파일에 여러 도메인의 로직을 혼합하여 작성하지 않습니다.\n\n#### 3.1.2. 임포트 및 의존성 관리\n\n*   **MUST**: 절대 경로 임포트를 사용합니다. (예: `from app.domains.auth import service`)\n*   **MUST**: `main.py`에서는 필요한 라우터를 등록하고, 각 라우터 파일에서 해당 도메인의 서비스 및 의존성을 주입합니다.\n*   **MUST**: `FastAPI`의 `Depends`를 활용하여 의존성 주입을 명확히 합니다.\n\n```python\n# MUST: 의존성 주입 예시 (app/domains/auth/router.py)\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.db.database import get_db\nfrom app.domains.auth.service import AuthService\nfrom app.domains.auth.schemas import UserCreate, UserResponse\n\nrouter = APIRouter(prefix=\"/auth\", tags=[\"Auth\"])\n\n@router.post(\"/register\", response_model=UserResponse)\ndef register_user(user: UserCreate, db: Session = Depends(get_db)):\n    # AuthService는 db 세션을 의존성으로 받습니다.\n    auth_service = AuthService(db)\n    db_user = auth_service.create_user(user)\n    if not db_user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"User already registered\")\n    return db_user\n```\n\n#### 3.1.3. 오류 처리 패턴\n\n*   **MUST**: FastAPI의 `HTTPException`을 사용하여 표준 HTTP 오류 응답을 반환합니다.\n*   **MUST**: 커스텀 예외를 정의할 경우, `HTTPException`을 상속하거나, `RequestValidationException`과 같은 FastAPI 내장 예외를 활용합니다.\n*   **MUST**: 외부 API 호출 시 `try-except` 블록을 사용하여 예상치 못한 오류를 처리하고, 사용자에게 의미 있는 메시지를 반환합니다.\n\n```python\n# MUST: 오류 처리 예시 (app/domains/content/service.py)\nfrom app.external.gemini_api import GeminiAPIClient\nfrom app.core.config import settings\n\nclass ContentService:\n    def __init__(self, db: Session):\n        self.db = db\n        self.gemini_client = GeminiAPIClient(api_key=settings.GEMINI_API_KEY)\n\n    async def generate_seo_article(self, keyword: str, tone: str) -> str:\n        try:\n            # 외부 API 호출\n            generated_text = await self.gemini_client.generate_text(\n                prompt=f\"'{keyword}'에 대해 {tone}으로 SEO 최적화된 글을 작성해줘.\"\n            )\n            return generated_text\n        except Exception as e:\n            # 구체적인 예외 처리 및 로깅\n            logger.error(f\"Gemini API 호출 중 오류 발생: {e}\")\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=\"콘텐츠 생성 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.\"\n            )\n\n# MUST NOT: 일반적인 Exception으로 모든 오류를 잡고 상세 정보 없이 반환\n# try:\n#     # ...\n# except Exception as e:\n#     raise HTTPException(status_code=500, detail=\"An error occurred\")\n```\n\n### 3.2. 프론트엔드 (Next.js / React)\n\n#### 3.2.1. 파일 구성 및 디렉토리 구조\n\n*   **MUST**: Next.js의 `app` 라우터 또는 `pages` 라우터 컨벤션을 따릅니다.\n*   **MUST**: 컴포넌트는 `components/` 디렉토리 내에서 재사용 가능한 단위로 분리합니다.\n*   **MUST**: 페이지별 컴포넌트는 `app/` 또는 `pages/` 디렉토리 내에 해당 라우트 경로에 맞춰 구성합니다.\n*   **MUST**: API 호출 로직은 `lib/api/` 또는 `services/` 디렉토리에 정의합니다.\n*   **MUST**: 상태 관리는 `store/` 또는 `hooks/` 디렉토리에 정의합니다.\n\n```\n/\n├── app/                  # Next.js App Router (또는 pages/)\n│   ├── layout.tsx\n│   ├── page.tsx          # 루트 페이지\n│   ├── auth/\n│   │   ├── login/page.tsx\n│   │   └── register/page.tsx\n│   ├── content/\n│   │   ├── generate/page.tsx\n│   │   └── history/page.tsx\n│   └── api/              # Next.js API Routes (백엔드 API가 아닌 프론트엔드 유틸리티 API)\n│       └── auth/[...nextauth].ts\n├── components/           # 재사용 가능한 UI 컴포넌트\n│   ├── ui/               # Shadcn/ui 등 기본 UI 요소\n│   │   ├── button.tsx\n│   │   └── input.tsx\n│   ├── common/           # 공통 컴포넌트\n│   │   ├── Header.tsx\n│   │   └── Footer.tsx\n│   ├── content/          # 도메인 특정 컴포넌트\n│   │   ├── ContentForm.tsx\n│   │   └── ContentHistoryList.tsx\n│   └── providers/        # Context Provider\n│       └── AuthProvider.tsx\n├── hooks/                # 커스텀 React Hooks\n│   ├── useAuth.ts\n│   └── useContentGenerator.ts\n├── lib/                  # 유틸리티 함수 및 설정\n│   ├── api/              # API 클라이언트 및 타입 정의\n│   │   ├── axios.ts\n│   │   └── types.ts\n│   ├── constants.ts\n│   └── utils.ts\n├── styles/               # Tailwind CSS 설정 및 전역 스타일\n│   └── globals.css\n├── public/               # 정적 자산\n└── types/                # 전역 타입 정의\n    └── index.d.ts\n```\n\n#### 3.2.2. 임포트 및 의존성 관리\n\n*   **MUST**: 절대 경로 임포트를 사용합니다. (예: `import { Button } from '@/components/ui/button'`)\n*   **MUST**: 컴포넌트 간의 의존성은 최소화하고, Props를 통해 데이터를 전달합니다.\n*   **MUST**: `useEffect` 훅 사용 시 의존성 배열을 명확히 지정하여 불필요한 렌더링을 방지합니다.\n\n```typescript\n// MUST: 절대 경로 임포트 및 Props 전달 예시\nimport React from 'react';\nimport { Button } from '@/components/ui/button'; // 절대 경로 임포트\n\ninterface MyComponentProps {\n  title: string;\n  onButtonClick: () => void;\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ title, onButtonClick }) => {\n  return (\n    <div>\n      <h1>{title}</h1>\n      <Button onClick={onButtonClick}>클릭</Button>\n    </div>\n  );\n};\n\nexport default MyComponent;\n```\n\n#### 3.2.3. 오류 처리 패턴\n\n*   **MUST**: API 호출 시 `try-catch` 블록을 사용하여 네트워크 오류 및 서버 응답 오류를 처리합니다.\n*   **MUST**: 사용자에게 친화적인 오류 메시지를 표시하고, 필요한 경우 재시도 옵션을 제공합니다.\n*   **MUST**: React Error Boundary를 사용하여 UI 렌더링 중 발생하는 예외를 처리하고 폴백 UI를 제공합니다.\n\n```typescript\n// MUST: API 오류 처리 예시 (lib/api/axios.ts)\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL,\n  timeout: 10000,\n});\n\napi.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    if (error.response) {\n      // 서버 응답 오류 (HTTP 상태 코드 2xx 외)\n      console.error('API 응답 오류:', error.response.status, error.response.data);\n      // 사용자에게 보여줄 메시지 처리 (예: 토스트 메시지)\n      // toast.error(`오류: ${error.response.data.detail || '알 수 없는 오류'}`);\n    } else if (error.request) {\n      // 요청이 전송되었으나 응답을 받지 못함 (네트워크 오류 등)\n      console.error('네트워크 오류:', error.request);\n      // toast.error('네트워크 연결을 확인해주세요.');\n    } else {\n      // 요청 설정 중 오류 발생\n      console.error('요청 설정 오류:', error.message);\n      // toast.error('요청 처리 중 오류가 발생했습니다.');\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default api;\n```\n\n## 4. 코드 스타일 규칙\n\n### 4.1. MUST 따르기\n\n*   **명명 규칙**:\n    *   **변수/함수**: `camelCase` (예: `userName`, `getUserData`)\n    *   **클래스/컴포넌트**: `PascalCase` (예: `AuthService`, `UserProfileCard`)\n    *   **상수**: `UPPER_SNAKE_CASE` (예: `MAX_RETRIES`, `API_KEY`)\n    *   **파일**: `snake_case` (Python), `kebab-case` 또는 `PascalCase` (Next.js 컴포넌트)\n    *   **Rationale**: 일관된 명명 규칙은 코드의 가독성을 높이고, 개발자가 변수, 함수, 클래스 등의 종류를 쉽게 파악할 수 있게 합니다.\n\n*   **들여쓰기**:\n    *   **Python**: 4칸 공백\n    *   **JavaScript/TypeScript**: 2칸 공백\n    *   **Rationale**: 일관된 들여쓰기는 코드 블록의 구조를 명확히 하고 가독성을 향상시킵니다.\n\n*   **주석**:\n    *   복잡한 로직, 비즈니스 규칙, 비직관적인 코드에만 주석을 추가합니다.\n    *   `TODO`, `FIXME` 등 특별한 지시어는 명확하게 사용합니다.\n    *   **Rationale**: 과도한 주석은 오히려 코드를 지저분하게 만들 수 있습니다. 코드가 스스로 설명하도록 작성하되, 필요한 경우에만 주석을 추가합니다.\n\n*   **함수/메서드 길이**:\n    *   하나의 함수/메서드는 하나의 책임만 가지도록 작성하며, 가급적 50줄을 넘지 않도록 합니다.\n    *   **Rationale**: 짧고 응집도 높은 함수는 테스트, 이해, 재사용이 용이합니다.\n\n*   **타입 명시 (TypeScript)**:\n    *   함수 매개변수, 반환 값, 변수 등에 명확하게 타입을 명시합니다.\n    *   **Rationale**: TypeScript의 강력한 타입 시스템을 활용하여 개발 단계에서 오류를 방지하고 코드의 안정성을 높입니다.\n\n```typescript\n// MUST: 타입 명시 예시\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction getUserById(id: number): User | undefined {\n  // ... 로직\n  return { id: 1, name: '홍길동', email: 'hong@example.com' };\n}\n\nconst user: User | undefined = getUserById(1);\n```\n\n### 4.2. MUST NOT 하기\n\n*   **매직 넘버/문자열**: 코드 내에 의미를 알 수 없는 숫자나 문자열 리터럴을 직접 사용하지 않습니다. 상수로 정의하여 사용합니다.\n    *   **Rationale**: 매직 넘버는 코드의 의미를 모호하게 만들고, 변경 시 오류를 유발할 수 있습니다.\n\n```python\n# MUST NOT: 매직 넘버\n# if status == 200:\n\n# MUST: 상수로 정의\nHTTP_STATUS_OK = 200\n# if status == HTTP_STATUS_OK:\n```\n\n*   **과도한 중첩**: `if-else` 또는 `for` 루프의 중첩 레벨을 3단계 이상으로 깊게 만들지 않습니다. 함수 분리 등을 통해 복잡도를 줄입니다.\n    *   **Rationale**: 깊은 중첩은 코드의 가독성을 해치고, 이해하기 어렵게 만듭니다.\n\n*   **전역 변수 남용**: 꼭 필요한 경우가 아니라면 전역 변수 사용을 지양합니다.\n    *   **Rationale**: 전역 변수는 예측 불가능한 부작용을 일으키고, 코드의 모듈성을 저해합니다.\n\n*   **단일 파일에 다중 책임**: 하나의 파일에 여러 비즈니스 도메인 또는 너무 많은 기능을 포함하지 않습니다. (예: 인증, 콘텐츠 생성, 사용자 관리가 한 파일에)\n    *   **Rationale**: 파일의 크기가 커지고 책임이 많아질수록 유지보수가 어려워지고, 코드 변경 시 사이드 이펙트 발생 가능성이 높아집니다.\n\n*   **복잡한 상태 관리 패턴**: MVP 단계에서는 React Context API 또는 간단한 전역 상태 관리 라이브러리(예: Zustand)를 사용하고, Redux와 같은 복잡한 패턴은 지양합니다.\n    *   **Rationale**: 초기 단계에서 과도하게 복잡한 상태 관리 패턴은 개발 생산성을 저해하고 학습 곡선을 높입니다.\n\n## 5. 아키텍처 패턴\n\n### 5.1. 컴포넌트/모듈 구조 가이드라인\n\n*   **책임 분리 (Separation of Concerns)**: 각 컴포넌트/모듈은 명확하고 단일한 책임을 가져야 합니다.\n    *   **백엔드**: `router`는 요청 라우팅, `service`는 비즈니스 로직, `models`는 데이터 모델 정의, `schemas`는 데이터 유효성 검사 및 직렬화/역직렬화에 집중합니다.\n    *   **프론트엔드**: `pages`는 라우팅 및 데이터 페칭, `components`는 UI 렌더링, `hooks`는 재사용 가능한 로직 캡슐화에 집중합니다.\n*   **재사용성**: 공통적으로 사용되는 유틸리티 함수, UI 컴포넌트, 타입 정의 등은 별도의 모듈로 분리하여 재사용성을 높입니다.\n*   **응집도 (Cohesion)**: 관련 있는 코드(데이터, 함수)는 하나의 모듈 내에 함께 위치하도록 합니다.\n*   **결합도 (Coupling)**: 모듈 간의 의존성은 최소화하고, 인터페이스를 통해 느슨하게 결합되도록 설계합니다.\n\n### 5.2. 데이터 흐름 패턴\n\n*   **단방향 데이터 흐름 (프론트엔드)**: React의 단방향 데이터 흐름 원칙을 따릅니다. 부모 컴포넌트에서 자식 컴포넌트로 Props를 통해 데이터를 전달합니다.\n*   **API 기반 통신**: 프론트엔드와 백엔드는 RESTful API를 통해 데이터를 주고받습니다.\n*   **데이터베이스 접근 계층**: 백엔드에서 데이터베이스 접근은 SQLAlchemy ORM을 통해 이루어지며, 직접적인 SQL 쿼리 사용은 지양합니다. `service` 계층은 `db` 계층을 통해 데이터에 접근합니다.\n\n### 5.3. 상태 관리 컨벤션 (프론트엔드)\n\n*   **로컬 상태**: 컴포넌트 내부에서만 필요한 상태는 `useState` 훅을 사용합니다.\n*   **전역 상태**: 여러 컴포넌트에서 공유되어야 하는 상태(예: 사용자 인증 정보, 테마 설정)는 React Context API 또는 Zustand와 같은 경량 상태 관리 라이브러리를 사용합니다.\n*   **서버 상태**: 서버에서 가져오는 데이터(예: 콘텐츠 목록, 사용자 프로필)는 React Query 또는 SWR과 같은 데이터 페칭 라이브러리를 사용하여 캐싱, 재검증, 동기화 등을 효율적으로 관리합니다.\n\n```typescript\n// MUST: React Query를 사용한 서버 상태 관리 예시 (hooks/useContentGenerator.ts)\nimport { useQuery } from '@tanstack/react-query';\nimport api from '@/lib/api/axios';\nimport { ContentHistory } from '@/types';\n\nconst fetchContentHistory = async (): Promise<ContentHistory[]> => {\n  const response = await api.get('/contents/history');\n  return response.data;\n};\n\nexport const useContentHistory = () => {\n  return useQuery<ContentHistory[], Error>({\n    queryKey: ['contentHistory'],\n    queryFn: fetchContentHistory,\n    staleTime: 5 * 60 * 1000, // 5분 동안 fresh 상태 유지\n  });\n};\n```\n\n### 5.4. API 디자인 표준 (백엔드)\n\n*   **RESTful 원칙**: 자원(Resource) 중심의 RESTful API 디자인 원칙을 따릅니다.\n    *   명사형 URL 사용 (예: `/users`, `/contents`)\n    *   HTTP 메서드(GET, POST, PUT, DELETE)를 통해 CRUD 작업 표현\n    *   상태 없는(Stateless) 통신\n*   **버전 관리**: API 버전 관리는 URL 경로를 통해 명시적으로 수행합니다. (예: `/v1/users`)\n*   **응답 형식**: 모든 API 응답은 JSON 형식을 따르며, 일관된 구조를 가집니다.\n    *   성공 응답: 데이터 객체 또는 배열\n    *   오류 응답: `code`, `message`, `details` 등을 포함하는 객체\n\n```json\n// MUST: 성공 응답 예시\n{\n  \"id\": 123,\n  \"title\": \"SEO 최적화된 블로그 글 제목\",\n  \"content\": \"...\"\n}\n\n// MUST: 오류 응답 예시\n{\n  \"detail\": \"인증에 실패했습니다.\",\n  \"code\": \"AUTH_FAILED\",\n  \"status_code\": 401\n}\n```\n\n*   **인증 및 권한 부여**: OAuth 2.0 및 JWT를 사용하여 사용자 인증 및 권한 부여를 처리합니다.\n*   **페이징 및 필터링**: 목록 조회 API는 페이징(offset/limit 또는 page/size) 및 필터링(쿼리 파라미터) 기능을 제공합니다.\n*   **입력 유효성 검사**: FastAPI의 Pydantic 모델을 사용하여 모든 API 요청의 입력 데이터를 엄격하게 유효성 검사합니다.",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-24T21:47:11.785Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-07-24T21:47:11.785Z"
    }
  ]
}
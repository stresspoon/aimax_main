
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Applicant
 * 
 */
export type Applicant = $Result.DefaultSelection<Prisma.$ApplicantPayload>
/**
 * Model SNSProfile
 * 
 */
export type SNSProfile = $Result.DefaultSelection<Prisma.$SNSProfilePayload>
/**
 * Model SelectionResult
 * 
 */
export type SelectionResult = $Result.DefaultSelection<Prisma.$SelectionResultPayload>
/**
 * Model MailHistory
 * 
 */
export type MailHistory = $Result.DefaultSelection<Prisma.$MailHistoryPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ApplicantStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicantStatus = (typeof ApplicantStatus)[keyof typeof ApplicantStatus]


export const SNSPlatform: {
  INSTAGRAM: 'INSTAGRAM',
  NAVER_BLOG: 'NAVER_BLOG',
  THREADS: 'THREADS'
};

export type SNSPlatform = (typeof SNSPlatform)[keyof typeof SNSPlatform]


export const ProcessingStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const MailType: {
  SELECTION_NOTIFICATION: 'SELECTION_NOTIFICATION',
  REJECTION_NOTIFICATION: 'REJECTION_NOTIFICATION',
  FOLLOW_UP: 'FOLLOW_UP',
  REMINDER: 'REMINDER'
};

export type MailType = (typeof MailType)[keyof typeof MailType]


export const MailStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  SCHEDULED: 'SCHEDULED'
};

export type MailStatus = (typeof MailStatus)[keyof typeof MailStatus]

}

export type ApplicantStatus = $Enums.ApplicantStatus

export const ApplicantStatus: typeof $Enums.ApplicantStatus

export type SNSPlatform = $Enums.SNSPlatform

export const SNSPlatform: typeof $Enums.SNSPlatform

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type MailType = $Enums.MailType

export const MailType: typeof $Enums.MailType

export type MailStatus = $Enums.MailStatus

export const MailStatus: typeof $Enums.MailStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicant`: Exposes CRUD operations for the **Applicant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicant.findMany()
    * ```
    */
  get applicant(): Prisma.ApplicantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sNSProfile`: Exposes CRUD operations for the **SNSProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SNSProfiles
    * const sNSProfiles = await prisma.sNSProfile.findMany()
    * ```
    */
  get sNSProfile(): Prisma.SNSProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.selectionResult`: Exposes CRUD operations for the **SelectionResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SelectionResults
    * const selectionResults = await prisma.selectionResult.findMany()
    * ```
    */
  get selectionResult(): Prisma.SelectionResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mailHistory`: Exposes CRUD operations for the **MailHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailHistories
    * const mailHistories = await prisma.mailHistory.findMany()
    * ```
    */
  get mailHistory(): Prisma.MailHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Campaign: 'Campaign',
    Applicant: 'Applicant',
    SNSProfile: 'SNSProfile',
    SelectionResult: 'SelectionResult',
    MailHistory: 'MailHistory',
    SyncLog: 'SyncLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "campaign" | "applicant" | "sNSProfile" | "selectionResult" | "mailHistory" | "syncLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Applicant: {
        payload: Prisma.$ApplicantPayload<ExtArgs>
        fields: Prisma.ApplicantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findFirst: {
            args: Prisma.ApplicantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          findMany: {
            args: Prisma.ApplicantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          create: {
            args: Prisma.ApplicantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          createMany: {
            args: Prisma.ApplicantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          delete: {
            args: Prisma.ApplicantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          update: {
            args: Prisma.ApplicantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          deleteMany: {
            args: Prisma.ApplicantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>[]
          }
          upsert: {
            args: Prisma.ApplicantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantPayload>
          }
          aggregate: {
            args: Prisma.ApplicantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicant>
          }
          groupBy: {
            args: Prisma.ApplicantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicantCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicantCountAggregateOutputType> | number
          }
        }
      }
      SNSProfile: {
        payload: Prisma.$SNSProfilePayload<ExtArgs>
        fields: Prisma.SNSProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SNSProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SNSProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          findFirst: {
            args: Prisma.SNSProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SNSProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          findMany: {
            args: Prisma.SNSProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>[]
          }
          create: {
            args: Prisma.SNSProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          createMany: {
            args: Prisma.SNSProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SNSProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>[]
          }
          delete: {
            args: Prisma.SNSProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          update: {
            args: Prisma.SNSProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          deleteMany: {
            args: Prisma.SNSProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SNSProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SNSProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>[]
          }
          upsert: {
            args: Prisma.SNSProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SNSProfilePayload>
          }
          aggregate: {
            args: Prisma.SNSProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSNSProfile>
          }
          groupBy: {
            args: Prisma.SNSProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SNSProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SNSProfileCountArgs<ExtArgs>
            result: $Utils.Optional<SNSProfileCountAggregateOutputType> | number
          }
        }
      }
      SelectionResult: {
        payload: Prisma.$SelectionResultPayload<ExtArgs>
        fields: Prisma.SelectionResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SelectionResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SelectionResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          findFirst: {
            args: Prisma.SelectionResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SelectionResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          findMany: {
            args: Prisma.SelectionResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>[]
          }
          create: {
            args: Prisma.SelectionResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          createMany: {
            args: Prisma.SelectionResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SelectionResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>[]
          }
          delete: {
            args: Prisma.SelectionResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          update: {
            args: Prisma.SelectionResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          deleteMany: {
            args: Prisma.SelectionResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SelectionResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SelectionResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>[]
          }
          upsert: {
            args: Prisma.SelectionResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionResultPayload>
          }
          aggregate: {
            args: Prisma.SelectionResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSelectionResult>
          }
          groupBy: {
            args: Prisma.SelectionResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<SelectionResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.SelectionResultCountArgs<ExtArgs>
            result: $Utils.Optional<SelectionResultCountAggregateOutputType> | number
          }
        }
      }
      MailHistory: {
        payload: Prisma.$MailHistoryPayload<ExtArgs>
        fields: Prisma.MailHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          findFirst: {
            args: Prisma.MailHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          findMany: {
            args: Prisma.MailHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>[]
          }
          create: {
            args: Prisma.MailHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          createMany: {
            args: Prisma.MailHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MailHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>[]
          }
          delete: {
            args: Prisma.MailHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          update: {
            args: Prisma.MailHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          deleteMany: {
            args: Prisma.MailHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MailHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MailHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>[]
          }
          upsert: {
            args: Prisma.MailHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MailHistoryPayload>
          }
          aggregate: {
            args: Prisma.MailHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMailHistory>
          }
          groupBy: {
            args: Prisma.MailHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MailHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<MailHistoryCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    campaign?: CampaignOmit
    applicant?: ApplicantOmit
    sNSProfile?: SNSProfileOmit
    selectionResult?: SelectionResultOmit
    mailHistory?: MailHistoryOmit
    syncLog?: SyncLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    campaigns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    applicants: number
    selectionResults: number
    mailHistories: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | CampaignCountOutputTypeCountApplicantsArgs
    selectionResults?: boolean | CampaignCountOutputTypeCountSelectionResultsArgs
    mailHistories?: boolean | CampaignCountOutputTypeCountMailHistoriesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountApplicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSelectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelectionResultWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMailHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailHistoryWhereInput
  }


  /**
   * Count Type ApplicantCountOutputType
   */

  export type ApplicantCountOutputType = {
    snsProfiles: number
    selectionResults: number
    mailHistories: number
  }

  export type ApplicantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snsProfiles?: boolean | ApplicantCountOutputTypeCountSnsProfilesArgs
    selectionResults?: boolean | ApplicantCountOutputTypeCountSelectionResultsArgs
    mailHistories?: boolean | ApplicantCountOutputTypeCountMailHistoriesArgs
  }

  // Custom InputTypes
  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantCountOutputType
     */
    select?: ApplicantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeCountSnsProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SNSProfileWhereInput
  }

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeCountSelectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelectionResultWhereInput
  }

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeCountMailHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    image: string | null
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "emailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      image: string | null
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sheetId: string | null
    sheetName: string | null
    sheetUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    sheetId: string | null
    sheetName: string | null
    sheetUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    sheetId: number
    sheetName: number
    sheetUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sheetId?: true
    sheetName?: true
    sheetUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sheetId?: true
    sheetName?: true
    sheetUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    sheetId?: true
    sheetName?: true
    sheetUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    sheetId: string | null
    sheetName: string | null
    sheetUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sheetId?: boolean
    sheetName?: boolean
    sheetUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    applicants?: boolean | Campaign$applicantsArgs<ExtArgs>
    selectionResults?: boolean | Campaign$selectionResultsArgs<ExtArgs>
    mailHistories?: boolean | Campaign$mailHistoriesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sheetId?: boolean
    sheetName?: boolean
    sheetUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    sheetId?: boolean
    sheetName?: boolean
    sheetUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    sheetId?: boolean
    sheetName?: boolean
    sheetUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "sheetId" | "sheetName" | "sheetUrl" | "isActive" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    applicants?: boolean | Campaign$applicantsArgs<ExtArgs>
    selectionResults?: boolean | Campaign$selectionResultsArgs<ExtArgs>
    mailHistories?: boolean | Campaign$mailHistoriesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      applicants: Prisma.$ApplicantPayload<ExtArgs>[]
      selectionResults: Prisma.$SelectionResultPayload<ExtArgs>[]
      mailHistories: Prisma.$MailHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      sheetId: string | null
      sheetName: string | null
      sheetUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applicants<T extends Campaign$applicantsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    selectionResults<T extends Campaign$selectionResultsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$selectionResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mailHistories<T extends Campaign$mailHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$mailHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly sheetId: FieldRef<"Campaign", 'String'>
    readonly sheetName: FieldRef<"Campaign", 'String'>
    readonly sheetUrl: FieldRef<"Campaign", 'String'>
    readonly isActive: FieldRef<"Campaign", 'Boolean'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly userId: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.applicants
   */
  export type Campaign$applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    cursor?: ApplicantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Campaign.selectionResults
   */
  export type Campaign$selectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    where?: SelectionResultWhereInput
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    cursor?: SelectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SelectionResultScalarFieldEnum | SelectionResultScalarFieldEnum[]
  }

  /**
   * Campaign.mailHistories
   */
  export type Campaign$mailHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    where?: MailHistoryWhereInput
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    cursor?: MailHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailHistoryScalarFieldEnum | MailHistoryScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model Applicant
   */

  export type AggregateApplicant = {
    _count: ApplicantCountAggregateOutputType | null
    _avg: ApplicantAvgAggregateOutputType | null
    _sum: ApplicantSumAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  export type ApplicantAvgAggregateOutputType = {
    sheetRowIndex: number | null
  }

  export type ApplicantSumAggregateOutputType = {
    sheetRowIndex: number | null
  }

  export type ApplicantMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    applicationDate: Date | null
    status: $Enums.ApplicantStatus | null
    notes: string | null
    sheetRowIndex: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    campaignId: string | null
  }

  export type ApplicantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    applicationDate: Date | null
    status: $Enums.ApplicantStatus | null
    notes: string | null
    sheetRowIndex: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    campaignId: string | null
  }

  export type ApplicantCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    applicationDate: number
    status: number
    notes: number
    sheetRowIndex: number
    lastUpdated: number
    createdAt: number
    campaignId: number
    _all: number
  }


  export type ApplicantAvgAggregateInputType = {
    sheetRowIndex?: true
  }

  export type ApplicantSumAggregateInputType = {
    sheetRowIndex?: true
  }

  export type ApplicantMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    applicationDate?: true
    status?: true
    notes?: true
    sheetRowIndex?: true
    lastUpdated?: true
    createdAt?: true
    campaignId?: true
  }

  export type ApplicantMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    applicationDate?: true
    status?: true
    notes?: true
    sheetRowIndex?: true
    lastUpdated?: true
    createdAt?: true
    campaignId?: true
  }

  export type ApplicantCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    applicationDate?: true
    status?: true
    notes?: true
    sheetRowIndex?: true
    lastUpdated?: true
    createdAt?: true
    campaignId?: true
    _all?: true
  }

  export type ApplicantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicant to aggregate.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applicants
    **/
    _count?: true | ApplicantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantMaxAggregateInputType
  }

  export type GetApplicantAggregateType<T extends ApplicantAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicant[P]>
      : GetScalarType<T[P], AggregateApplicant[P]>
  }




  export type ApplicantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantWhereInput
    orderBy?: ApplicantOrderByWithAggregationInput | ApplicantOrderByWithAggregationInput[]
    by: ApplicantScalarFieldEnum[] | ApplicantScalarFieldEnum
    having?: ApplicantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantCountAggregateInputType | true
    _avg?: ApplicantAvgAggregateInputType
    _sum?: ApplicantSumAggregateInputType
    _min?: ApplicantMinAggregateInputType
    _max?: ApplicantMaxAggregateInputType
  }

  export type ApplicantGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    applicationDate: Date
    status: $Enums.ApplicantStatus
    notes: string | null
    sheetRowIndex: number
    lastUpdated: Date
    createdAt: Date
    campaignId: string
    _count: ApplicantCountAggregateOutputType | null
    _avg: ApplicantAvgAggregateOutputType | null
    _sum: ApplicantSumAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  type GetApplicantGroupByPayload<T extends ApplicantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
        }
      >
    >


  export type ApplicantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    applicationDate?: boolean
    status?: boolean
    notes?: boolean
    sheetRowIndex?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    campaignId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    snsProfiles?: boolean | Applicant$snsProfilesArgs<ExtArgs>
    selectionResults?: boolean | Applicant$selectionResultsArgs<ExtArgs>
    mailHistories?: boolean | Applicant$mailHistoriesArgs<ExtArgs>
    _count?: boolean | ApplicantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    applicationDate?: boolean
    status?: boolean
    notes?: boolean
    sheetRowIndex?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    campaignId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    applicationDate?: boolean
    status?: boolean
    notes?: boolean
    sheetRowIndex?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    campaignId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicant"]>

  export type ApplicantSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    applicationDate?: boolean
    status?: boolean
    notes?: boolean
    sheetRowIndex?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    campaignId?: boolean
  }

  export type ApplicantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "applicationDate" | "status" | "notes" | "sheetRowIndex" | "lastUpdated" | "createdAt" | "campaignId", ExtArgs["result"]["applicant"]>
  export type ApplicantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    snsProfiles?: boolean | Applicant$snsProfilesArgs<ExtArgs>
    selectionResults?: boolean | Applicant$selectionResultsArgs<ExtArgs>
    mailHistories?: boolean | Applicant$mailHistoriesArgs<ExtArgs>
    _count?: boolean | ApplicantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ApplicantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ApplicantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Applicant"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      snsProfiles: Prisma.$SNSProfilePayload<ExtArgs>[]
      selectionResults: Prisma.$SelectionResultPayload<ExtArgs>[]
      mailHistories: Prisma.$MailHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      applicationDate: Date
      status: $Enums.ApplicantStatus
      notes: string | null
      sheetRowIndex: number
      lastUpdated: Date
      createdAt: Date
      campaignId: string
    }, ExtArgs["result"]["applicant"]>
    composites: {}
  }

  type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantDefaultArgs> = $Result.GetResult<Prisma.$ApplicantPayload, S>

  type ApplicantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicantCountAggregateInputType | true
    }

  export interface ApplicantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Applicant'], meta: { name: 'Applicant' } }
    /**
     * Find zero or one Applicant that matches the filter.
     * @param {ApplicantFindUniqueArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicantFindUniqueArgs>(args: SelectSubset<T, ApplicantFindUniqueArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicantFindUniqueOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicantFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicantFindFirstArgs>(args?: SelectSubset<T, ApplicantFindFirstArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicantFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicant.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicantWithIdOnly = await prisma.applicant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicantFindManyArgs>(args?: SelectSubset<T, ApplicantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicant.
     * @param {ApplicantCreateArgs} args - Arguments to create a Applicant.
     * @example
     * // Create one Applicant
     * const Applicant = await prisma.applicant.create({
     *   data: {
     *     // ... data to create a Applicant
     *   }
     * })
     * 
     */
    create<T extends ApplicantCreateArgs>(args: SelectSubset<T, ApplicantCreateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicants.
     * @param {ApplicantCreateManyArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicant = await prisma.applicant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicantCreateManyArgs>(args?: SelectSubset<T, ApplicantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applicants and returns the data saved in the database.
     * @param {ApplicantCreateManyAndReturnArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicant = await prisma.applicant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applicants and only return the `id`
     * const applicantWithIdOnly = await prisma.applicant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicantCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Applicant.
     * @param {ApplicantDeleteArgs} args - Arguments to delete one Applicant.
     * @example
     * // Delete one Applicant
     * const Applicant = await prisma.applicant.delete({
     *   where: {
     *     // ... filter to delete one Applicant
     *   }
     * })
     * 
     */
    delete<T extends ApplicantDeleteArgs>(args: SelectSubset<T, ApplicantDeleteArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicant.
     * @param {ApplicantUpdateArgs} args - Arguments to update one Applicant.
     * @example
     * // Update one Applicant
     * const applicant = await prisma.applicant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicantUpdateArgs>(args: SelectSubset<T, ApplicantUpdateArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicants.
     * @param {ApplicantDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicantDeleteManyArgs>(args?: SelectSubset<T, ApplicantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicantUpdateManyArgs>(args: SelectSubset<T, ApplicantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants and returns the data updated in the database.
     * @param {ApplicantUpdateManyAndReturnArgs} args - Arguments to update many Applicants.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applicants and only return the `id`
     * const applicantWithIdOnly = await prisma.applicant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicantUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Applicant.
     * @param {ApplicantUpsertArgs} args - Arguments to update or create a Applicant.
     * @example
     * // Update or create a Applicant
     * const applicant = await prisma.applicant.upsert({
     *   create: {
     *     // ... data to create a Applicant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicant we want to update
     *   }
     * })
     */
    upsert<T extends ApplicantUpsertArgs>(args: SelectSubset<T, ApplicantUpsertArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicant.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends ApplicantCountArgs>(
      args?: Subset<T, ApplicantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantAggregateArgs>(args: Subset<T, ApplicantAggregateArgs>): Prisma.PrismaPromise<GetApplicantAggregateType<T>>

    /**
     * Group by Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicantGroupByArgs['orderBy'] }
        : { orderBy?: ApplicantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Applicant model
   */
  readonly fields: ApplicantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Applicant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    snsProfiles<T extends Applicant$snsProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$snsProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    selectionResults<T extends Applicant$selectionResultsArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$selectionResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mailHistories<T extends Applicant$mailHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Applicant$mailHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Applicant model
   */
  interface ApplicantFieldRefs {
    readonly id: FieldRef<"Applicant", 'String'>
    readonly name: FieldRef<"Applicant", 'String'>
    readonly email: FieldRef<"Applicant", 'String'>
    readonly phone: FieldRef<"Applicant", 'String'>
    readonly applicationDate: FieldRef<"Applicant", 'DateTime'>
    readonly status: FieldRef<"Applicant", 'ApplicantStatus'>
    readonly notes: FieldRef<"Applicant", 'String'>
    readonly sheetRowIndex: FieldRef<"Applicant", 'Int'>
    readonly lastUpdated: FieldRef<"Applicant", 'DateTime'>
    readonly createdAt: FieldRef<"Applicant", 'DateTime'>
    readonly campaignId: FieldRef<"Applicant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Applicant findUnique
   */
  export type ApplicantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findUniqueOrThrow
   */
  export type ApplicantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findFirst
   */
  export type ApplicantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findFirstOrThrow
   */
  export type ApplicantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicant to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     */
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant findMany
   */
  export type ApplicantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter, which Applicants to fetch.
     */
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     */
    orderBy?: ApplicantOrderByWithRelationInput | ApplicantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applicants.
     */
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     */
    skip?: number
    distinct?: ApplicantScalarFieldEnum | ApplicantScalarFieldEnum[]
  }

  /**
   * Applicant create
   */
  export type ApplicantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to create a Applicant.
     */
    data: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
  }

  /**
   * Applicant createMany
   */
  export type ApplicantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applicants.
     */
    data: ApplicantCreateManyInput | ApplicantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Applicant createManyAndReturn
   */
  export type ApplicantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * The data used to create many Applicants.
     */
    data: ApplicantCreateManyInput | ApplicantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Applicant update
   */
  export type ApplicantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The data needed to update a Applicant.
     */
    data: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
    /**
     * Choose, which Applicant to update.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant updateMany
   */
  export type ApplicantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applicants.
     */
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to update.
     */
    limit?: number
  }

  /**
   * Applicant updateManyAndReturn
   */
  export type ApplicantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * The data used to update Applicants.
     */
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Applicant upsert
   */
  export type ApplicantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * The filter to search for the Applicant to update in case it exists.
     */
    where: ApplicantWhereUniqueInput
    /**
     * In case the Applicant found by the `where` argument doesn't exist, create a new Applicant with this data.
     */
    create: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
    /**
     * In case the Applicant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
  }

  /**
   * Applicant delete
   */
  export type ApplicantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
    /**
     * Filter which Applicant to delete.
     */
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant deleteMany
   */
  export type ApplicantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applicants to delete
     */
    where?: ApplicantWhereInput
    /**
     * Limit how many Applicants to delete.
     */
    limit?: number
  }

  /**
   * Applicant.snsProfiles
   */
  export type Applicant$snsProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    where?: SNSProfileWhereInput
    orderBy?: SNSProfileOrderByWithRelationInput | SNSProfileOrderByWithRelationInput[]
    cursor?: SNSProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SNSProfileScalarFieldEnum | SNSProfileScalarFieldEnum[]
  }

  /**
   * Applicant.selectionResults
   */
  export type Applicant$selectionResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    where?: SelectionResultWhereInput
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    cursor?: SelectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SelectionResultScalarFieldEnum | SelectionResultScalarFieldEnum[]
  }

  /**
   * Applicant.mailHistories
   */
  export type Applicant$mailHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    where?: MailHistoryWhereInput
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    cursor?: MailHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailHistoryScalarFieldEnum | MailHistoryScalarFieldEnum[]
  }

  /**
   * Applicant without action
   */
  export type ApplicantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantInclude<ExtArgs> | null
  }


  /**
   * Model SNSProfile
   */

  export type AggregateSNSProfile = {
    _count: SNSProfileCountAggregateOutputType | null
    _avg: SNSProfileAvgAggregateOutputType | null
    _sum: SNSProfileSumAggregateOutputType | null
    _min: SNSProfileMinAggregateOutputType | null
    _max: SNSProfileMaxAggregateOutputType | null
  }

  export type SNSProfileAvgAggregateOutputType = {
    followers: number | null
    visitors: number | null
  }

  export type SNSProfileSumAggregateOutputType = {
    followers: number | null
    visitors: number | null
  }

  export type SNSProfileMinAggregateOutputType = {
    id: string | null
    platform: $Enums.SNSPlatform | null
    url: string | null
    handle: string | null
    followers: number | null
    visitors: number | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
  }

  export type SNSProfileMaxAggregateOutputType = {
    id: string | null
    platform: $Enums.SNSPlatform | null
    url: string | null
    handle: string | null
    followers: number | null
    visitors: number | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
  }

  export type SNSProfileCountAggregateOutputType = {
    id: number
    platform: number
    url: number
    handle: number
    followers: number
    visitors: number
    isValid: number
    createdAt: number
    updatedAt: number
    applicantId: number
    _all: number
  }


  export type SNSProfileAvgAggregateInputType = {
    followers?: true
    visitors?: true
  }

  export type SNSProfileSumAggregateInputType = {
    followers?: true
    visitors?: true
  }

  export type SNSProfileMinAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    handle?: true
    followers?: true
    visitors?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
  }

  export type SNSProfileMaxAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    handle?: true
    followers?: true
    visitors?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
  }

  export type SNSProfileCountAggregateInputType = {
    id?: true
    platform?: true
    url?: true
    handle?: true
    followers?: true
    visitors?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    _all?: true
  }

  export type SNSProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SNSProfile to aggregate.
     */
    where?: SNSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SNSProfiles to fetch.
     */
    orderBy?: SNSProfileOrderByWithRelationInput | SNSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SNSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SNSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SNSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SNSProfiles
    **/
    _count?: true | SNSProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SNSProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SNSProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SNSProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SNSProfileMaxAggregateInputType
  }

  export type GetSNSProfileAggregateType<T extends SNSProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateSNSProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSNSProfile[P]>
      : GetScalarType<T[P], AggregateSNSProfile[P]>
  }




  export type SNSProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SNSProfileWhereInput
    orderBy?: SNSProfileOrderByWithAggregationInput | SNSProfileOrderByWithAggregationInput[]
    by: SNSProfileScalarFieldEnum[] | SNSProfileScalarFieldEnum
    having?: SNSProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SNSProfileCountAggregateInputType | true
    _avg?: SNSProfileAvgAggregateInputType
    _sum?: SNSProfileSumAggregateInputType
    _min?: SNSProfileMinAggregateInputType
    _max?: SNSProfileMaxAggregateInputType
  }

  export type SNSProfileGroupByOutputType = {
    id: string
    platform: $Enums.SNSPlatform
    url: string
    handle: string | null
    followers: number | null
    visitors: number | null
    isValid: boolean
    createdAt: Date
    updatedAt: Date
    applicantId: string
    _count: SNSProfileCountAggregateOutputType | null
    _avg: SNSProfileAvgAggregateOutputType | null
    _sum: SNSProfileSumAggregateOutputType | null
    _min: SNSProfileMinAggregateOutputType | null
    _max: SNSProfileMaxAggregateOutputType | null
  }

  type GetSNSProfileGroupByPayload<T extends SNSProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SNSProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SNSProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SNSProfileGroupByOutputType[P]>
            : GetScalarType<T[P], SNSProfileGroupByOutputType[P]>
        }
      >
    >


  export type SNSProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    handle?: boolean
    followers?: boolean
    visitors?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sNSProfile"]>

  export type SNSProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    handle?: boolean
    followers?: boolean
    visitors?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sNSProfile"]>

  export type SNSProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    url?: boolean
    handle?: boolean
    followers?: boolean
    visitors?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sNSProfile"]>

  export type SNSProfileSelectScalar = {
    id?: boolean
    platform?: boolean
    url?: boolean
    handle?: boolean
    followers?: boolean
    visitors?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
  }

  export type SNSProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "url" | "handle" | "followers" | "visitors" | "isValid" | "createdAt" | "updatedAt" | "applicantId", ExtArgs["result"]["sNSProfile"]>
  export type SNSProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }
  export type SNSProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }
  export type SNSProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
  }

  export type $SNSProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SNSProfile"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: $Enums.SNSPlatform
      url: string
      handle: string | null
      followers: number | null
      visitors: number | null
      isValid: boolean
      createdAt: Date
      updatedAt: Date
      applicantId: string
    }, ExtArgs["result"]["sNSProfile"]>
    composites: {}
  }

  type SNSProfileGetPayload<S extends boolean | null | undefined | SNSProfileDefaultArgs> = $Result.GetResult<Prisma.$SNSProfilePayload, S>

  type SNSProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SNSProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SNSProfileCountAggregateInputType | true
    }

  export interface SNSProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SNSProfile'], meta: { name: 'SNSProfile' } }
    /**
     * Find zero or one SNSProfile that matches the filter.
     * @param {SNSProfileFindUniqueArgs} args - Arguments to find a SNSProfile
     * @example
     * // Get one SNSProfile
     * const sNSProfile = await prisma.sNSProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SNSProfileFindUniqueArgs>(args: SelectSubset<T, SNSProfileFindUniqueArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SNSProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SNSProfileFindUniqueOrThrowArgs} args - Arguments to find a SNSProfile
     * @example
     * // Get one SNSProfile
     * const sNSProfile = await prisma.sNSProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SNSProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, SNSProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SNSProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileFindFirstArgs} args - Arguments to find a SNSProfile
     * @example
     * // Get one SNSProfile
     * const sNSProfile = await prisma.sNSProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SNSProfileFindFirstArgs>(args?: SelectSubset<T, SNSProfileFindFirstArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SNSProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileFindFirstOrThrowArgs} args - Arguments to find a SNSProfile
     * @example
     * // Get one SNSProfile
     * const sNSProfile = await prisma.sNSProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SNSProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, SNSProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SNSProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SNSProfiles
     * const sNSProfiles = await prisma.sNSProfile.findMany()
     * 
     * // Get first 10 SNSProfiles
     * const sNSProfiles = await prisma.sNSProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sNSProfileWithIdOnly = await prisma.sNSProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SNSProfileFindManyArgs>(args?: SelectSubset<T, SNSProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SNSProfile.
     * @param {SNSProfileCreateArgs} args - Arguments to create a SNSProfile.
     * @example
     * // Create one SNSProfile
     * const SNSProfile = await prisma.sNSProfile.create({
     *   data: {
     *     // ... data to create a SNSProfile
     *   }
     * })
     * 
     */
    create<T extends SNSProfileCreateArgs>(args: SelectSubset<T, SNSProfileCreateArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SNSProfiles.
     * @param {SNSProfileCreateManyArgs} args - Arguments to create many SNSProfiles.
     * @example
     * // Create many SNSProfiles
     * const sNSProfile = await prisma.sNSProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SNSProfileCreateManyArgs>(args?: SelectSubset<T, SNSProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SNSProfiles and returns the data saved in the database.
     * @param {SNSProfileCreateManyAndReturnArgs} args - Arguments to create many SNSProfiles.
     * @example
     * // Create many SNSProfiles
     * const sNSProfile = await prisma.sNSProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SNSProfiles and only return the `id`
     * const sNSProfileWithIdOnly = await prisma.sNSProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SNSProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, SNSProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SNSProfile.
     * @param {SNSProfileDeleteArgs} args - Arguments to delete one SNSProfile.
     * @example
     * // Delete one SNSProfile
     * const SNSProfile = await prisma.sNSProfile.delete({
     *   where: {
     *     // ... filter to delete one SNSProfile
     *   }
     * })
     * 
     */
    delete<T extends SNSProfileDeleteArgs>(args: SelectSubset<T, SNSProfileDeleteArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SNSProfile.
     * @param {SNSProfileUpdateArgs} args - Arguments to update one SNSProfile.
     * @example
     * // Update one SNSProfile
     * const sNSProfile = await prisma.sNSProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SNSProfileUpdateArgs>(args: SelectSubset<T, SNSProfileUpdateArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SNSProfiles.
     * @param {SNSProfileDeleteManyArgs} args - Arguments to filter SNSProfiles to delete.
     * @example
     * // Delete a few SNSProfiles
     * const { count } = await prisma.sNSProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SNSProfileDeleteManyArgs>(args?: SelectSubset<T, SNSProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SNSProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SNSProfiles
     * const sNSProfile = await prisma.sNSProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SNSProfileUpdateManyArgs>(args: SelectSubset<T, SNSProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SNSProfiles and returns the data updated in the database.
     * @param {SNSProfileUpdateManyAndReturnArgs} args - Arguments to update many SNSProfiles.
     * @example
     * // Update many SNSProfiles
     * const sNSProfile = await prisma.sNSProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SNSProfiles and only return the `id`
     * const sNSProfileWithIdOnly = await prisma.sNSProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SNSProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, SNSProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SNSProfile.
     * @param {SNSProfileUpsertArgs} args - Arguments to update or create a SNSProfile.
     * @example
     * // Update or create a SNSProfile
     * const sNSProfile = await prisma.sNSProfile.upsert({
     *   create: {
     *     // ... data to create a SNSProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SNSProfile we want to update
     *   }
     * })
     */
    upsert<T extends SNSProfileUpsertArgs>(args: SelectSubset<T, SNSProfileUpsertArgs<ExtArgs>>): Prisma__SNSProfileClient<$Result.GetResult<Prisma.$SNSProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SNSProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileCountArgs} args - Arguments to filter SNSProfiles to count.
     * @example
     * // Count the number of SNSProfiles
     * const count = await prisma.sNSProfile.count({
     *   where: {
     *     // ... the filter for the SNSProfiles we want to count
     *   }
     * })
    **/
    count<T extends SNSProfileCountArgs>(
      args?: Subset<T, SNSProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SNSProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SNSProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SNSProfileAggregateArgs>(args: Subset<T, SNSProfileAggregateArgs>): Prisma.PrismaPromise<GetSNSProfileAggregateType<T>>

    /**
     * Group by SNSProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SNSProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SNSProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SNSProfileGroupByArgs['orderBy'] }
        : { orderBy?: SNSProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SNSProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSNSProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SNSProfile model
   */
  readonly fields: SNSProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SNSProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SNSProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SNSProfile model
   */
  interface SNSProfileFieldRefs {
    readonly id: FieldRef<"SNSProfile", 'String'>
    readonly platform: FieldRef<"SNSProfile", 'SNSPlatform'>
    readonly url: FieldRef<"SNSProfile", 'String'>
    readonly handle: FieldRef<"SNSProfile", 'String'>
    readonly followers: FieldRef<"SNSProfile", 'Int'>
    readonly visitors: FieldRef<"SNSProfile", 'Int'>
    readonly isValid: FieldRef<"SNSProfile", 'Boolean'>
    readonly createdAt: FieldRef<"SNSProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"SNSProfile", 'DateTime'>
    readonly applicantId: FieldRef<"SNSProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SNSProfile findUnique
   */
  export type SNSProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter, which SNSProfile to fetch.
     */
    where: SNSProfileWhereUniqueInput
  }

  /**
   * SNSProfile findUniqueOrThrow
   */
  export type SNSProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter, which SNSProfile to fetch.
     */
    where: SNSProfileWhereUniqueInput
  }

  /**
   * SNSProfile findFirst
   */
  export type SNSProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter, which SNSProfile to fetch.
     */
    where?: SNSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SNSProfiles to fetch.
     */
    orderBy?: SNSProfileOrderByWithRelationInput | SNSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SNSProfiles.
     */
    cursor?: SNSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SNSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SNSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SNSProfiles.
     */
    distinct?: SNSProfileScalarFieldEnum | SNSProfileScalarFieldEnum[]
  }

  /**
   * SNSProfile findFirstOrThrow
   */
  export type SNSProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter, which SNSProfile to fetch.
     */
    where?: SNSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SNSProfiles to fetch.
     */
    orderBy?: SNSProfileOrderByWithRelationInput | SNSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SNSProfiles.
     */
    cursor?: SNSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SNSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SNSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SNSProfiles.
     */
    distinct?: SNSProfileScalarFieldEnum | SNSProfileScalarFieldEnum[]
  }

  /**
   * SNSProfile findMany
   */
  export type SNSProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter, which SNSProfiles to fetch.
     */
    where?: SNSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SNSProfiles to fetch.
     */
    orderBy?: SNSProfileOrderByWithRelationInput | SNSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SNSProfiles.
     */
    cursor?: SNSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SNSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SNSProfiles.
     */
    skip?: number
    distinct?: SNSProfileScalarFieldEnum | SNSProfileScalarFieldEnum[]
  }

  /**
   * SNSProfile create
   */
  export type SNSProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a SNSProfile.
     */
    data: XOR<SNSProfileCreateInput, SNSProfileUncheckedCreateInput>
  }

  /**
   * SNSProfile createMany
   */
  export type SNSProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SNSProfiles.
     */
    data: SNSProfileCreateManyInput | SNSProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SNSProfile createManyAndReturn
   */
  export type SNSProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * The data used to create many SNSProfiles.
     */
    data: SNSProfileCreateManyInput | SNSProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SNSProfile update
   */
  export type SNSProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a SNSProfile.
     */
    data: XOR<SNSProfileUpdateInput, SNSProfileUncheckedUpdateInput>
    /**
     * Choose, which SNSProfile to update.
     */
    where: SNSProfileWhereUniqueInput
  }

  /**
   * SNSProfile updateMany
   */
  export type SNSProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SNSProfiles.
     */
    data: XOR<SNSProfileUpdateManyMutationInput, SNSProfileUncheckedUpdateManyInput>
    /**
     * Filter which SNSProfiles to update
     */
    where?: SNSProfileWhereInput
    /**
     * Limit how many SNSProfiles to update.
     */
    limit?: number
  }

  /**
   * SNSProfile updateManyAndReturn
   */
  export type SNSProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * The data used to update SNSProfiles.
     */
    data: XOR<SNSProfileUpdateManyMutationInput, SNSProfileUncheckedUpdateManyInput>
    /**
     * Filter which SNSProfiles to update
     */
    where?: SNSProfileWhereInput
    /**
     * Limit how many SNSProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SNSProfile upsert
   */
  export type SNSProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the SNSProfile to update in case it exists.
     */
    where: SNSProfileWhereUniqueInput
    /**
     * In case the SNSProfile found by the `where` argument doesn't exist, create a new SNSProfile with this data.
     */
    create: XOR<SNSProfileCreateInput, SNSProfileUncheckedCreateInput>
    /**
     * In case the SNSProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SNSProfileUpdateInput, SNSProfileUncheckedUpdateInput>
  }

  /**
   * SNSProfile delete
   */
  export type SNSProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
    /**
     * Filter which SNSProfile to delete.
     */
    where: SNSProfileWhereUniqueInput
  }

  /**
   * SNSProfile deleteMany
   */
  export type SNSProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SNSProfiles to delete
     */
    where?: SNSProfileWhereInput
    /**
     * Limit how many SNSProfiles to delete.
     */
    limit?: number
  }

  /**
   * SNSProfile without action
   */
  export type SNSProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SNSProfile
     */
    select?: SNSProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SNSProfile
     */
    omit?: SNSProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SNSProfileInclude<ExtArgs> | null
  }


  /**
   * Model SelectionResult
   */

  export type AggregateSelectionResult = {
    _count: SelectionResultCountAggregateOutputType | null
    _min: SelectionResultMinAggregateOutputType | null
    _max: SelectionResultMaxAggregateOutputType | null
  }

  export type SelectionResultMinAggregateOutputType = {
    id: string | null
    isSelected: boolean | null
    selectionReason: string | null
    selectionDate: Date | null
    processingStatus: $Enums.ProcessingStatus | null
    sheetUpdated: boolean | null
    sheetUpdateDate: Date | null
    emailSent: boolean | null
    emailSentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    campaignId: string | null
  }

  export type SelectionResultMaxAggregateOutputType = {
    id: string | null
    isSelected: boolean | null
    selectionReason: string | null
    selectionDate: Date | null
    processingStatus: $Enums.ProcessingStatus | null
    sheetUpdated: boolean | null
    sheetUpdateDate: Date | null
    emailSent: boolean | null
    emailSentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    campaignId: string | null
  }

  export type SelectionResultCountAggregateOutputType = {
    id: number
    isSelected: number
    selectionReason: number
    selectionDate: number
    qualifyingPlatforms: number
    processingStatus: number
    sheetUpdated: number
    sheetUpdateDate: number
    emailSent: number
    emailSentDate: number
    createdAt: number
    updatedAt: number
    applicantId: number
    campaignId: number
    meetsCriteria: number
    snsDataSnapshot: number
    _all: number
  }


  export type SelectionResultMinAggregateInputType = {
    id?: true
    isSelected?: true
    selectionReason?: true
    selectionDate?: true
    processingStatus?: true
    sheetUpdated?: true
    sheetUpdateDate?: true
    emailSent?: true
    emailSentDate?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
  }

  export type SelectionResultMaxAggregateInputType = {
    id?: true
    isSelected?: true
    selectionReason?: true
    selectionDate?: true
    processingStatus?: true
    sheetUpdated?: true
    sheetUpdateDate?: true
    emailSent?: true
    emailSentDate?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
  }

  export type SelectionResultCountAggregateInputType = {
    id?: true
    isSelected?: true
    selectionReason?: true
    selectionDate?: true
    qualifyingPlatforms?: true
    processingStatus?: true
    sheetUpdated?: true
    sheetUpdateDate?: true
    emailSent?: true
    emailSentDate?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
    meetsCriteria?: true
    snsDataSnapshot?: true
    _all?: true
  }

  export type SelectionResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelectionResult to aggregate.
     */
    where?: SelectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionResults to fetch.
     */
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SelectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SelectionResults
    **/
    _count?: true | SelectionResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SelectionResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SelectionResultMaxAggregateInputType
  }

  export type GetSelectionResultAggregateType<T extends SelectionResultAggregateArgs> = {
        [P in keyof T & keyof AggregateSelectionResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelectionResult[P]>
      : GetScalarType<T[P], AggregateSelectionResult[P]>
  }




  export type SelectionResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelectionResultWhereInput
    orderBy?: SelectionResultOrderByWithAggregationInput | SelectionResultOrderByWithAggregationInput[]
    by: SelectionResultScalarFieldEnum[] | SelectionResultScalarFieldEnum
    having?: SelectionResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SelectionResultCountAggregateInputType | true
    _min?: SelectionResultMinAggregateInputType
    _max?: SelectionResultMaxAggregateInputType
  }

  export type SelectionResultGroupByOutputType = {
    id: string
    isSelected: boolean
    selectionReason: string
    selectionDate: Date
    qualifyingPlatforms: JsonValue
    processingStatus: $Enums.ProcessingStatus
    sheetUpdated: boolean
    sheetUpdateDate: Date | null
    emailSent: boolean
    emailSentDate: Date | null
    createdAt: Date
    updatedAt: Date
    applicantId: string
    campaignId: string
    meetsCriteria: JsonValue
    snsDataSnapshot: JsonValue
    _count: SelectionResultCountAggregateOutputType | null
    _min: SelectionResultMinAggregateOutputType | null
    _max: SelectionResultMaxAggregateOutputType | null
  }

  type GetSelectionResultGroupByPayload<T extends SelectionResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SelectionResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SelectionResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SelectionResultGroupByOutputType[P]>
            : GetScalarType<T[P], SelectionResultGroupByOutputType[P]>
        }
      >
    >


  export type SelectionResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isSelected?: boolean
    selectionReason?: boolean
    selectionDate?: boolean
    qualifyingPlatforms?: boolean
    processingStatus?: boolean
    sheetUpdated?: boolean
    sheetUpdateDate?: boolean
    emailSent?: boolean
    emailSentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    meetsCriteria?: boolean
    snsDataSnapshot?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionResult"]>

  export type SelectionResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isSelected?: boolean
    selectionReason?: boolean
    selectionDate?: boolean
    qualifyingPlatforms?: boolean
    processingStatus?: boolean
    sheetUpdated?: boolean
    sheetUpdateDate?: boolean
    emailSent?: boolean
    emailSentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    meetsCriteria?: boolean
    snsDataSnapshot?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionResult"]>

  export type SelectionResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isSelected?: boolean
    selectionReason?: boolean
    selectionDate?: boolean
    qualifyingPlatforms?: boolean
    processingStatus?: boolean
    sheetUpdated?: boolean
    sheetUpdateDate?: boolean
    emailSent?: boolean
    emailSentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    meetsCriteria?: boolean
    snsDataSnapshot?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionResult"]>

  export type SelectionResultSelectScalar = {
    id?: boolean
    isSelected?: boolean
    selectionReason?: boolean
    selectionDate?: boolean
    qualifyingPlatforms?: boolean
    processingStatus?: boolean
    sheetUpdated?: boolean
    sheetUpdateDate?: boolean
    emailSent?: boolean
    emailSentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    meetsCriteria?: boolean
    snsDataSnapshot?: boolean
  }

  export type SelectionResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isSelected" | "selectionReason" | "selectionDate" | "qualifyingPlatforms" | "processingStatus" | "sheetUpdated" | "sheetUpdateDate" | "emailSent" | "emailSentDate" | "createdAt" | "updatedAt" | "applicantId" | "campaignId" | "meetsCriteria" | "snsDataSnapshot", ExtArgs["result"]["selectionResult"]>
  export type SelectionResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type SelectionResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type SelectionResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $SelectionResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SelectionResult"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isSelected: boolean
      selectionReason: string
      selectionDate: Date
      qualifyingPlatforms: Prisma.JsonValue
      processingStatus: $Enums.ProcessingStatus
      sheetUpdated: boolean
      sheetUpdateDate: Date | null
      emailSent: boolean
      emailSentDate: Date | null
      createdAt: Date
      updatedAt: Date
      applicantId: string
      campaignId: string
      meetsCriteria: Prisma.JsonValue
      snsDataSnapshot: Prisma.JsonValue
    }, ExtArgs["result"]["selectionResult"]>
    composites: {}
  }

  type SelectionResultGetPayload<S extends boolean | null | undefined | SelectionResultDefaultArgs> = $Result.GetResult<Prisma.$SelectionResultPayload, S>

  type SelectionResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SelectionResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SelectionResultCountAggregateInputType | true
    }

  export interface SelectionResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SelectionResult'], meta: { name: 'SelectionResult' } }
    /**
     * Find zero or one SelectionResult that matches the filter.
     * @param {SelectionResultFindUniqueArgs} args - Arguments to find a SelectionResult
     * @example
     * // Get one SelectionResult
     * const selectionResult = await prisma.selectionResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SelectionResultFindUniqueArgs>(args: SelectSubset<T, SelectionResultFindUniqueArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SelectionResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SelectionResultFindUniqueOrThrowArgs} args - Arguments to find a SelectionResult
     * @example
     * // Get one SelectionResult
     * const selectionResult = await prisma.selectionResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SelectionResultFindUniqueOrThrowArgs>(args: SelectSubset<T, SelectionResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelectionResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultFindFirstArgs} args - Arguments to find a SelectionResult
     * @example
     * // Get one SelectionResult
     * const selectionResult = await prisma.selectionResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SelectionResultFindFirstArgs>(args?: SelectSubset<T, SelectionResultFindFirstArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SelectionResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultFindFirstOrThrowArgs} args - Arguments to find a SelectionResult
     * @example
     * // Get one SelectionResult
     * const selectionResult = await prisma.selectionResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SelectionResultFindFirstOrThrowArgs>(args?: SelectSubset<T, SelectionResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SelectionResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SelectionResults
     * const selectionResults = await prisma.selectionResult.findMany()
     * 
     * // Get first 10 SelectionResults
     * const selectionResults = await prisma.selectionResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const selectionResultWithIdOnly = await prisma.selectionResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SelectionResultFindManyArgs>(args?: SelectSubset<T, SelectionResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SelectionResult.
     * @param {SelectionResultCreateArgs} args - Arguments to create a SelectionResult.
     * @example
     * // Create one SelectionResult
     * const SelectionResult = await prisma.selectionResult.create({
     *   data: {
     *     // ... data to create a SelectionResult
     *   }
     * })
     * 
     */
    create<T extends SelectionResultCreateArgs>(args: SelectSubset<T, SelectionResultCreateArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SelectionResults.
     * @param {SelectionResultCreateManyArgs} args - Arguments to create many SelectionResults.
     * @example
     * // Create many SelectionResults
     * const selectionResult = await prisma.selectionResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SelectionResultCreateManyArgs>(args?: SelectSubset<T, SelectionResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SelectionResults and returns the data saved in the database.
     * @param {SelectionResultCreateManyAndReturnArgs} args - Arguments to create many SelectionResults.
     * @example
     * // Create many SelectionResults
     * const selectionResult = await prisma.selectionResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SelectionResults and only return the `id`
     * const selectionResultWithIdOnly = await prisma.selectionResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SelectionResultCreateManyAndReturnArgs>(args?: SelectSubset<T, SelectionResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SelectionResult.
     * @param {SelectionResultDeleteArgs} args - Arguments to delete one SelectionResult.
     * @example
     * // Delete one SelectionResult
     * const SelectionResult = await prisma.selectionResult.delete({
     *   where: {
     *     // ... filter to delete one SelectionResult
     *   }
     * })
     * 
     */
    delete<T extends SelectionResultDeleteArgs>(args: SelectSubset<T, SelectionResultDeleteArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SelectionResult.
     * @param {SelectionResultUpdateArgs} args - Arguments to update one SelectionResult.
     * @example
     * // Update one SelectionResult
     * const selectionResult = await prisma.selectionResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SelectionResultUpdateArgs>(args: SelectSubset<T, SelectionResultUpdateArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SelectionResults.
     * @param {SelectionResultDeleteManyArgs} args - Arguments to filter SelectionResults to delete.
     * @example
     * // Delete a few SelectionResults
     * const { count } = await prisma.selectionResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SelectionResultDeleteManyArgs>(args?: SelectSubset<T, SelectionResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SelectionResults
     * const selectionResult = await prisma.selectionResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SelectionResultUpdateManyArgs>(args: SelectSubset<T, SelectionResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelectionResults and returns the data updated in the database.
     * @param {SelectionResultUpdateManyAndReturnArgs} args - Arguments to update many SelectionResults.
     * @example
     * // Update many SelectionResults
     * const selectionResult = await prisma.selectionResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SelectionResults and only return the `id`
     * const selectionResultWithIdOnly = await prisma.selectionResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SelectionResultUpdateManyAndReturnArgs>(args: SelectSubset<T, SelectionResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SelectionResult.
     * @param {SelectionResultUpsertArgs} args - Arguments to update or create a SelectionResult.
     * @example
     * // Update or create a SelectionResult
     * const selectionResult = await prisma.selectionResult.upsert({
     *   create: {
     *     // ... data to create a SelectionResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SelectionResult we want to update
     *   }
     * })
     */
    upsert<T extends SelectionResultUpsertArgs>(args: SelectSubset<T, SelectionResultUpsertArgs<ExtArgs>>): Prisma__SelectionResultClient<$Result.GetResult<Prisma.$SelectionResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SelectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultCountArgs} args - Arguments to filter SelectionResults to count.
     * @example
     * // Count the number of SelectionResults
     * const count = await prisma.selectionResult.count({
     *   where: {
     *     // ... the filter for the SelectionResults we want to count
     *   }
     * })
    **/
    count<T extends SelectionResultCountArgs>(
      args?: Subset<T, SelectionResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SelectionResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SelectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SelectionResultAggregateArgs>(args: Subset<T, SelectionResultAggregateArgs>): Prisma.PrismaPromise<GetSelectionResultAggregateType<T>>

    /**
     * Group by SelectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SelectionResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SelectionResultGroupByArgs['orderBy'] }
        : { orderBy?: SelectionResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SelectionResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSelectionResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SelectionResult model
   */
  readonly fields: SelectionResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SelectionResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SelectionResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SelectionResult model
   */
  interface SelectionResultFieldRefs {
    readonly id: FieldRef<"SelectionResult", 'String'>
    readonly isSelected: FieldRef<"SelectionResult", 'Boolean'>
    readonly selectionReason: FieldRef<"SelectionResult", 'String'>
    readonly selectionDate: FieldRef<"SelectionResult", 'DateTime'>
    readonly qualifyingPlatforms: FieldRef<"SelectionResult", 'Json'>
    readonly processingStatus: FieldRef<"SelectionResult", 'ProcessingStatus'>
    readonly sheetUpdated: FieldRef<"SelectionResult", 'Boolean'>
    readonly sheetUpdateDate: FieldRef<"SelectionResult", 'DateTime'>
    readonly emailSent: FieldRef<"SelectionResult", 'Boolean'>
    readonly emailSentDate: FieldRef<"SelectionResult", 'DateTime'>
    readonly createdAt: FieldRef<"SelectionResult", 'DateTime'>
    readonly updatedAt: FieldRef<"SelectionResult", 'DateTime'>
    readonly applicantId: FieldRef<"SelectionResult", 'String'>
    readonly campaignId: FieldRef<"SelectionResult", 'String'>
    readonly meetsCriteria: FieldRef<"SelectionResult", 'Json'>
    readonly snsDataSnapshot: FieldRef<"SelectionResult", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SelectionResult findUnique
   */
  export type SelectionResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter, which SelectionResult to fetch.
     */
    where: SelectionResultWhereUniqueInput
  }

  /**
   * SelectionResult findUniqueOrThrow
   */
  export type SelectionResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter, which SelectionResult to fetch.
     */
    where: SelectionResultWhereUniqueInput
  }

  /**
   * SelectionResult findFirst
   */
  export type SelectionResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter, which SelectionResult to fetch.
     */
    where?: SelectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionResults to fetch.
     */
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelectionResults.
     */
    cursor?: SelectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelectionResults.
     */
    distinct?: SelectionResultScalarFieldEnum | SelectionResultScalarFieldEnum[]
  }

  /**
   * SelectionResult findFirstOrThrow
   */
  export type SelectionResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter, which SelectionResult to fetch.
     */
    where?: SelectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionResults to fetch.
     */
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelectionResults.
     */
    cursor?: SelectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelectionResults.
     */
    distinct?: SelectionResultScalarFieldEnum | SelectionResultScalarFieldEnum[]
  }

  /**
   * SelectionResult findMany
   */
  export type SelectionResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter, which SelectionResults to fetch.
     */
    where?: SelectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionResults to fetch.
     */
    orderBy?: SelectionResultOrderByWithRelationInput | SelectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SelectionResults.
     */
    cursor?: SelectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionResults.
     */
    skip?: number
    distinct?: SelectionResultScalarFieldEnum | SelectionResultScalarFieldEnum[]
  }

  /**
   * SelectionResult create
   */
  export type SelectionResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * The data needed to create a SelectionResult.
     */
    data: XOR<SelectionResultCreateInput, SelectionResultUncheckedCreateInput>
  }

  /**
   * SelectionResult createMany
   */
  export type SelectionResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SelectionResults.
     */
    data: SelectionResultCreateManyInput | SelectionResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SelectionResult createManyAndReturn
   */
  export type SelectionResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * The data used to create many SelectionResults.
     */
    data: SelectionResultCreateManyInput | SelectionResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelectionResult update
   */
  export type SelectionResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * The data needed to update a SelectionResult.
     */
    data: XOR<SelectionResultUpdateInput, SelectionResultUncheckedUpdateInput>
    /**
     * Choose, which SelectionResult to update.
     */
    where: SelectionResultWhereUniqueInput
  }

  /**
   * SelectionResult updateMany
   */
  export type SelectionResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SelectionResults.
     */
    data: XOR<SelectionResultUpdateManyMutationInput, SelectionResultUncheckedUpdateManyInput>
    /**
     * Filter which SelectionResults to update
     */
    where?: SelectionResultWhereInput
    /**
     * Limit how many SelectionResults to update.
     */
    limit?: number
  }

  /**
   * SelectionResult updateManyAndReturn
   */
  export type SelectionResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * The data used to update SelectionResults.
     */
    data: XOR<SelectionResultUpdateManyMutationInput, SelectionResultUncheckedUpdateManyInput>
    /**
     * Filter which SelectionResults to update
     */
    where?: SelectionResultWhereInput
    /**
     * Limit how many SelectionResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelectionResult upsert
   */
  export type SelectionResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * The filter to search for the SelectionResult to update in case it exists.
     */
    where: SelectionResultWhereUniqueInput
    /**
     * In case the SelectionResult found by the `where` argument doesn't exist, create a new SelectionResult with this data.
     */
    create: XOR<SelectionResultCreateInput, SelectionResultUncheckedCreateInput>
    /**
     * In case the SelectionResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SelectionResultUpdateInput, SelectionResultUncheckedUpdateInput>
  }

  /**
   * SelectionResult delete
   */
  export type SelectionResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
    /**
     * Filter which SelectionResult to delete.
     */
    where: SelectionResultWhereUniqueInput
  }

  /**
   * SelectionResult deleteMany
   */
  export type SelectionResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelectionResults to delete
     */
    where?: SelectionResultWhereInput
    /**
     * Limit how many SelectionResults to delete.
     */
    limit?: number
  }

  /**
   * SelectionResult without action
   */
  export type SelectionResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionResult
     */
    select?: SelectionResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionResult
     */
    omit?: SelectionResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionResultInclude<ExtArgs> | null
  }


  /**
   * Model MailHistory
   */

  export type AggregateMailHistory = {
    _count: MailHistoryCountAggregateOutputType | null
    _min: MailHistoryMinAggregateOutputType | null
    _max: MailHistoryMaxAggregateOutputType | null
  }

  export type MailHistoryMinAggregateOutputType = {
    id: string | null
    mailType: $Enums.MailType | null
    recipient: string | null
    subject: string | null
    content: string | null
    status: $Enums.MailStatus | null
    sentAt: Date | null
    failReason: string | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    campaignId: string | null
  }

  export type MailHistoryMaxAggregateOutputType = {
    id: string | null
    mailType: $Enums.MailType | null
    recipient: string | null
    subject: string | null
    content: string | null
    status: $Enums.MailStatus | null
    sentAt: Date | null
    failReason: string | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    applicantId: string | null
    campaignId: string | null
  }

  export type MailHistoryCountAggregateOutputType = {
    id: number
    mailType: number
    recipient: number
    subject: number
    content: number
    status: number
    sentAt: number
    failReason: number
    scheduledAt: number
    createdAt: number
    updatedAt: number
    applicantId: number
    campaignId: number
    _all: number
  }


  export type MailHistoryMinAggregateInputType = {
    id?: true
    mailType?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    failReason?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
  }

  export type MailHistoryMaxAggregateInputType = {
    id?: true
    mailType?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    failReason?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
  }

  export type MailHistoryCountAggregateInputType = {
    id?: true
    mailType?: true
    recipient?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    failReason?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    applicantId?: true
    campaignId?: true
    _all?: true
  }

  export type MailHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailHistory to aggregate.
     */
    where?: MailHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailHistories to fetch.
     */
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailHistories
    **/
    _count?: true | MailHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailHistoryMaxAggregateInputType
  }

  export type GetMailHistoryAggregateType<T extends MailHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMailHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailHistory[P]>
      : GetScalarType<T[P], AggregateMailHistory[P]>
  }




  export type MailHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailHistoryWhereInput
    orderBy?: MailHistoryOrderByWithAggregationInput | MailHistoryOrderByWithAggregationInput[]
    by: MailHistoryScalarFieldEnum[] | MailHistoryScalarFieldEnum
    having?: MailHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailHistoryCountAggregateInputType | true
    _min?: MailHistoryMinAggregateInputType
    _max?: MailHistoryMaxAggregateInputType
  }

  export type MailHistoryGroupByOutputType = {
    id: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status: $Enums.MailStatus
    sentAt: Date | null
    failReason: string | null
    scheduledAt: Date | null
    createdAt: Date
    updatedAt: Date
    applicantId: string
    campaignId: string
    _count: MailHistoryCountAggregateOutputType | null
    _min: MailHistoryMinAggregateOutputType | null
    _max: MailHistoryMaxAggregateOutputType | null
  }

  type GetMailHistoryGroupByPayload<T extends MailHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], MailHistoryGroupByOutputType[P]>
        }
      >
    >


  export type MailHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mailType?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    failReason?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailHistory"]>

  export type MailHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mailType?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    failReason?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailHistory"]>

  export type MailHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mailType?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    failReason?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailHistory"]>

  export type MailHistorySelectScalar = {
    id?: boolean
    mailType?: boolean
    recipient?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    failReason?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantId?: boolean
    campaignId?: boolean
  }

  export type MailHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mailType" | "recipient" | "subject" | "content" | "status" | "sentAt" | "failReason" | "scheduledAt" | "createdAt" | "updatedAt" | "applicantId" | "campaignId", ExtArgs["result"]["mailHistory"]>
  export type MailHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MailHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MailHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $MailHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MailHistory"
    objects: {
      applicant: Prisma.$ApplicantPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mailType: $Enums.MailType
      recipient: string
      subject: string
      content: string
      status: $Enums.MailStatus
      sentAt: Date | null
      failReason: string | null
      scheduledAt: Date | null
      createdAt: Date
      updatedAt: Date
      applicantId: string
      campaignId: string
    }, ExtArgs["result"]["mailHistory"]>
    composites: {}
  }

  type MailHistoryGetPayload<S extends boolean | null | undefined | MailHistoryDefaultArgs> = $Result.GetResult<Prisma.$MailHistoryPayload, S>

  type MailHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MailHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MailHistoryCountAggregateInputType | true
    }

  export interface MailHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MailHistory'], meta: { name: 'MailHistory' } }
    /**
     * Find zero or one MailHistory that matches the filter.
     * @param {MailHistoryFindUniqueArgs} args - Arguments to find a MailHistory
     * @example
     * // Get one MailHistory
     * const mailHistory = await prisma.mailHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MailHistoryFindUniqueArgs>(args: SelectSubset<T, MailHistoryFindUniqueArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MailHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MailHistoryFindUniqueOrThrowArgs} args - Arguments to find a MailHistory
     * @example
     * // Get one MailHistory
     * const mailHistory = await prisma.mailHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MailHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MailHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MailHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryFindFirstArgs} args - Arguments to find a MailHistory
     * @example
     * // Get one MailHistory
     * const mailHistory = await prisma.mailHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MailHistoryFindFirstArgs>(args?: SelectSubset<T, MailHistoryFindFirstArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MailHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryFindFirstOrThrowArgs} args - Arguments to find a MailHistory
     * @example
     * // Get one MailHistory
     * const mailHistory = await prisma.mailHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MailHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MailHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MailHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailHistories
     * const mailHistories = await prisma.mailHistory.findMany()
     * 
     * // Get first 10 MailHistories
     * const mailHistories = await prisma.mailHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailHistoryWithIdOnly = await prisma.mailHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MailHistoryFindManyArgs>(args?: SelectSubset<T, MailHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MailHistory.
     * @param {MailHistoryCreateArgs} args - Arguments to create a MailHistory.
     * @example
     * // Create one MailHistory
     * const MailHistory = await prisma.mailHistory.create({
     *   data: {
     *     // ... data to create a MailHistory
     *   }
     * })
     * 
     */
    create<T extends MailHistoryCreateArgs>(args: SelectSubset<T, MailHistoryCreateArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MailHistories.
     * @param {MailHistoryCreateManyArgs} args - Arguments to create many MailHistories.
     * @example
     * // Create many MailHistories
     * const mailHistory = await prisma.mailHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MailHistoryCreateManyArgs>(args?: SelectSubset<T, MailHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MailHistories and returns the data saved in the database.
     * @param {MailHistoryCreateManyAndReturnArgs} args - Arguments to create many MailHistories.
     * @example
     * // Create many MailHistories
     * const mailHistory = await prisma.mailHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MailHistories and only return the `id`
     * const mailHistoryWithIdOnly = await prisma.mailHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MailHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MailHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MailHistory.
     * @param {MailHistoryDeleteArgs} args - Arguments to delete one MailHistory.
     * @example
     * // Delete one MailHistory
     * const MailHistory = await prisma.mailHistory.delete({
     *   where: {
     *     // ... filter to delete one MailHistory
     *   }
     * })
     * 
     */
    delete<T extends MailHistoryDeleteArgs>(args: SelectSubset<T, MailHistoryDeleteArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MailHistory.
     * @param {MailHistoryUpdateArgs} args - Arguments to update one MailHistory.
     * @example
     * // Update one MailHistory
     * const mailHistory = await prisma.mailHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MailHistoryUpdateArgs>(args: SelectSubset<T, MailHistoryUpdateArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MailHistories.
     * @param {MailHistoryDeleteManyArgs} args - Arguments to filter MailHistories to delete.
     * @example
     * // Delete a few MailHistories
     * const { count } = await prisma.mailHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MailHistoryDeleteManyArgs>(args?: SelectSubset<T, MailHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailHistories
     * const mailHistory = await prisma.mailHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MailHistoryUpdateManyArgs>(args: SelectSubset<T, MailHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailHistories and returns the data updated in the database.
     * @param {MailHistoryUpdateManyAndReturnArgs} args - Arguments to update many MailHistories.
     * @example
     * // Update many MailHistories
     * const mailHistory = await prisma.mailHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MailHistories and only return the `id`
     * const mailHistoryWithIdOnly = await prisma.mailHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MailHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, MailHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MailHistory.
     * @param {MailHistoryUpsertArgs} args - Arguments to update or create a MailHistory.
     * @example
     * // Update or create a MailHistory
     * const mailHistory = await prisma.mailHistory.upsert({
     *   create: {
     *     // ... data to create a MailHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailHistory we want to update
     *   }
     * })
     */
    upsert<T extends MailHistoryUpsertArgs>(args: SelectSubset<T, MailHistoryUpsertArgs<ExtArgs>>): Prisma__MailHistoryClient<$Result.GetResult<Prisma.$MailHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MailHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryCountArgs} args - Arguments to filter MailHistories to count.
     * @example
     * // Count the number of MailHistories
     * const count = await prisma.mailHistory.count({
     *   where: {
     *     // ... the filter for the MailHistories we want to count
     *   }
     * })
    **/
    count<T extends MailHistoryCountArgs>(
      args?: Subset<T, MailHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailHistoryAggregateArgs>(args: Subset<T, MailHistoryAggregateArgs>): Prisma.PrismaPromise<GetMailHistoryAggregateType<T>>

    /**
     * Group by MailHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailHistoryGroupByArgs['orderBy'] }
        : { orderBy?: MailHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MailHistory model
   */
  readonly fields: MailHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicant<T extends ApplicantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantDefaultArgs<ExtArgs>>): Prisma__ApplicantClient<$Result.GetResult<Prisma.$ApplicantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MailHistory model
   */
  interface MailHistoryFieldRefs {
    readonly id: FieldRef<"MailHistory", 'String'>
    readonly mailType: FieldRef<"MailHistory", 'MailType'>
    readonly recipient: FieldRef<"MailHistory", 'String'>
    readonly subject: FieldRef<"MailHistory", 'String'>
    readonly content: FieldRef<"MailHistory", 'String'>
    readonly status: FieldRef<"MailHistory", 'MailStatus'>
    readonly sentAt: FieldRef<"MailHistory", 'DateTime'>
    readonly failReason: FieldRef<"MailHistory", 'String'>
    readonly scheduledAt: FieldRef<"MailHistory", 'DateTime'>
    readonly createdAt: FieldRef<"MailHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"MailHistory", 'DateTime'>
    readonly applicantId: FieldRef<"MailHistory", 'String'>
    readonly campaignId: FieldRef<"MailHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MailHistory findUnique
   */
  export type MailHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MailHistory to fetch.
     */
    where: MailHistoryWhereUniqueInput
  }

  /**
   * MailHistory findUniqueOrThrow
   */
  export type MailHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MailHistory to fetch.
     */
    where: MailHistoryWhereUniqueInput
  }

  /**
   * MailHistory findFirst
   */
  export type MailHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MailHistory to fetch.
     */
    where?: MailHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailHistories to fetch.
     */
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailHistories.
     */
    cursor?: MailHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailHistories.
     */
    distinct?: MailHistoryScalarFieldEnum | MailHistoryScalarFieldEnum[]
  }

  /**
   * MailHistory findFirstOrThrow
   */
  export type MailHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MailHistory to fetch.
     */
    where?: MailHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailHistories to fetch.
     */
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailHistories.
     */
    cursor?: MailHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailHistories.
     */
    distinct?: MailHistoryScalarFieldEnum | MailHistoryScalarFieldEnum[]
  }

  /**
   * MailHistory findMany
   */
  export type MailHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MailHistories to fetch.
     */
    where?: MailHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailHistories to fetch.
     */
    orderBy?: MailHistoryOrderByWithRelationInput | MailHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailHistories.
     */
    cursor?: MailHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailHistories.
     */
    skip?: number
    distinct?: MailHistoryScalarFieldEnum | MailHistoryScalarFieldEnum[]
  }

  /**
   * MailHistory create
   */
  export type MailHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MailHistory.
     */
    data: XOR<MailHistoryCreateInput, MailHistoryUncheckedCreateInput>
  }

  /**
   * MailHistory createMany
   */
  export type MailHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MailHistories.
     */
    data: MailHistoryCreateManyInput | MailHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MailHistory createManyAndReturn
   */
  export type MailHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many MailHistories.
     */
    data: MailHistoryCreateManyInput | MailHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MailHistory update
   */
  export type MailHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MailHistory.
     */
    data: XOR<MailHistoryUpdateInput, MailHistoryUncheckedUpdateInput>
    /**
     * Choose, which MailHistory to update.
     */
    where: MailHistoryWhereUniqueInput
  }

  /**
   * MailHistory updateMany
   */
  export type MailHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MailHistories.
     */
    data: XOR<MailHistoryUpdateManyMutationInput, MailHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MailHistories to update
     */
    where?: MailHistoryWhereInput
    /**
     * Limit how many MailHistories to update.
     */
    limit?: number
  }

  /**
   * MailHistory updateManyAndReturn
   */
  export type MailHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * The data used to update MailHistories.
     */
    data: XOR<MailHistoryUpdateManyMutationInput, MailHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MailHistories to update
     */
    where?: MailHistoryWhereInput
    /**
     * Limit how many MailHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MailHistory upsert
   */
  export type MailHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MailHistory to update in case it exists.
     */
    where: MailHistoryWhereUniqueInput
    /**
     * In case the MailHistory found by the `where` argument doesn't exist, create a new MailHistory with this data.
     */
    create: XOR<MailHistoryCreateInput, MailHistoryUncheckedCreateInput>
    /**
     * In case the MailHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailHistoryUpdateInput, MailHistoryUncheckedUpdateInput>
  }

  /**
   * MailHistory delete
   */
  export type MailHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
    /**
     * Filter which MailHistory to delete.
     */
    where: MailHistoryWhereUniqueInput
  }

  /**
   * MailHistory deleteMany
   */
  export type MailHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailHistories to delete
     */
    where?: MailHistoryWhereInput
    /**
     * Limit how many MailHistories to delete.
     */
    limit?: number
  }

  /**
   * MailHistory without action
   */
  export type MailHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailHistory
     */
    select?: MailHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MailHistory
     */
    omit?: MailHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MailHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    newApplicants: number | null
    updatedApplicants: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    newApplicants: number | null
    updatedApplicants: number | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    success: boolean | null
    newApplicants: number | null
    updatedApplicants: number | null
    lastSyncTime: Date | null
    createdAt: Date | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    success: boolean | null
    newApplicants: number | null
    updatedApplicants: number | null
    lastSyncTime: Date | null
    createdAt: Date | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    success: number
    newApplicants: number
    updatedApplicants: number
    errors: number
    lastSyncTime: number
    createdAt: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    newApplicants?: true
    updatedApplicants?: true
  }

  export type SyncLogSumAggregateInputType = {
    newApplicants?: true
    updatedApplicants?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    success?: true
    newApplicants?: true
    updatedApplicants?: true
    lastSyncTime?: true
    createdAt?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    success?: true
    newApplicants?: true
    updatedApplicants?: true
    lastSyncTime?: true
    createdAt?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    success?: true
    newApplicants?: true
    updatedApplicants?: true
    errors?: true
    lastSyncTime?: true
    createdAt?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    success: boolean
    newApplicants: number
    updatedApplicants: number
    errors: JsonValue
    lastSyncTime: Date
    createdAt: Date
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    success?: boolean
    newApplicants?: boolean
    updatedApplicants?: boolean
    errors?: boolean
    lastSyncTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    success?: boolean
    newApplicants?: boolean
    updatedApplicants?: boolean
    errors?: boolean
    lastSyncTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    success?: boolean
    newApplicants?: boolean
    updatedApplicants?: boolean
    errors?: boolean
    lastSyncTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    success?: boolean
    newApplicants?: boolean
    updatedApplicants?: boolean
    errors?: boolean
    lastSyncTime?: boolean
    createdAt?: boolean
  }

  export type SyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "success" | "newApplicants" | "updatedApplicants" | "errors" | "lastSyncTime" | "createdAt", ExtArgs["result"]["syncLog"]>

  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      success: boolean
      newApplicants: number
      updatedApplicants: number
      errors: Prisma.JsonValue
      lastSyncTime: Date
      createdAt: Date
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs and returns the data updated in the database.
     * @param {SyncLogUpdateManyAndReturnArgs} args - Arguments to update many SyncLogs.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly success: FieldRef<"SyncLog", 'Boolean'>
    readonly newApplicants: FieldRef<"SyncLog", 'Int'>
    readonly updatedApplicants: FieldRef<"SyncLog", 'Int'>
    readonly errors: FieldRef<"SyncLog", 'Json'>
    readonly lastSyncTime: FieldRef<"SyncLog", 'DateTime'>
    readonly createdAt: FieldRef<"SyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog updateManyAndReturn
   */
  export type SyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to delete.
     */
    limit?: number
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    sheetId: 'sheetId',
    sheetName: 'sheetName',
    sheetUrl: 'sheetUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const ApplicantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    applicationDate: 'applicationDate',
    status: 'status',
    notes: 'notes',
    sheetRowIndex: 'sheetRowIndex',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    campaignId: 'campaignId'
  };

  export type ApplicantScalarFieldEnum = (typeof ApplicantScalarFieldEnum)[keyof typeof ApplicantScalarFieldEnum]


  export const SNSProfileScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    url: 'url',
    handle: 'handle',
    followers: 'followers',
    visitors: 'visitors',
    isValid: 'isValid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    applicantId: 'applicantId'
  };

  export type SNSProfileScalarFieldEnum = (typeof SNSProfileScalarFieldEnum)[keyof typeof SNSProfileScalarFieldEnum]


  export const SelectionResultScalarFieldEnum: {
    id: 'id',
    isSelected: 'isSelected',
    selectionReason: 'selectionReason',
    selectionDate: 'selectionDate',
    qualifyingPlatforms: 'qualifyingPlatforms',
    processingStatus: 'processingStatus',
    sheetUpdated: 'sheetUpdated',
    sheetUpdateDate: 'sheetUpdateDate',
    emailSent: 'emailSent',
    emailSentDate: 'emailSentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    applicantId: 'applicantId',
    campaignId: 'campaignId',
    meetsCriteria: 'meetsCriteria',
    snsDataSnapshot: 'snsDataSnapshot'
  };

  export type SelectionResultScalarFieldEnum = (typeof SelectionResultScalarFieldEnum)[keyof typeof SelectionResultScalarFieldEnum]


  export const MailHistoryScalarFieldEnum: {
    id: 'id',
    mailType: 'mailType',
    recipient: 'recipient',
    subject: 'subject',
    content: 'content',
    status: 'status',
    sentAt: 'sentAt',
    failReason: 'failReason',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    applicantId: 'applicantId',
    campaignId: 'campaignId'
  };

  export type MailHistoryScalarFieldEnum = (typeof MailHistoryScalarFieldEnum)[keyof typeof MailHistoryScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    success: 'success',
    newApplicants: 'newApplicants',
    updatedApplicants: 'updatedApplicants',
    errors: 'errors',
    lastSyncTime: 'lastSyncTime',
    createdAt: 'createdAt'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ApplicantStatus'
   */
  export type EnumApplicantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantStatus'>
    


  /**
   * Reference to a field of type 'ApplicantStatus[]'
   */
  export type ListEnumApplicantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantStatus[]'>
    


  /**
   * Reference to a field of type 'SNSPlatform'
   */
  export type EnumSNSPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SNSPlatform'>
    


  /**
   * Reference to a field of type 'SNSPlatform[]'
   */
  export type ListEnumSNSPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SNSPlatform[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'MailType'
   */
  export type EnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType'>
    


  /**
   * Reference to a field of type 'MailType[]'
   */
  export type ListEnumMailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailType[]'>
    


  /**
   * Reference to a field of type 'MailStatus'
   */
  export type EnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus'>
    


  /**
   * Reference to a field of type 'MailStatus[]'
   */
  export type ListEnumMailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    campaigns?: CampaignListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    sheetId?: StringNullableFilter<"Campaign"> | string | null
    sheetName?: StringNullableFilter<"Campaign"> | string | null
    sheetUrl?: StringNullableFilter<"Campaign"> | string | null
    isActive?: BoolFilter<"Campaign"> | boolean
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    userId?: StringFilter<"Campaign"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    applicants?: ApplicantListRelationFilter
    selectionResults?: SelectionResultListRelationFilter
    mailHistories?: MailHistoryListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sheetId?: SortOrderInput | SortOrder
    sheetName?: SortOrderInput | SortOrder
    sheetUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    applicants?: ApplicantOrderByRelationAggregateInput
    selectionResults?: SelectionResultOrderByRelationAggregateInput
    mailHistories?: MailHistoryOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    sheetId?: StringNullableFilter<"Campaign"> | string | null
    sheetName?: StringNullableFilter<"Campaign"> | string | null
    sheetUrl?: StringNullableFilter<"Campaign"> | string | null
    isActive?: BoolFilter<"Campaign"> | boolean
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    userId?: StringFilter<"Campaign"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    applicants?: ApplicantListRelationFilter
    selectionResults?: SelectionResultListRelationFilter
    mailHistories?: MailHistoryListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sheetId?: SortOrderInput | SortOrder
    sheetName?: SortOrderInput | SortOrder
    sheetUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    sheetId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    sheetName?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    sheetUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    isActive?: BoolWithAggregatesFilter<"Campaign"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
  }

  export type ApplicantWhereInput = {
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    id?: StringFilter<"Applicant"> | string
    name?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    phone?: StringNullableFilter<"Applicant"> | string | null
    applicationDate?: DateTimeFilter<"Applicant"> | Date | string
    status?: EnumApplicantStatusFilter<"Applicant"> | $Enums.ApplicantStatus
    notes?: StringNullableFilter<"Applicant"> | string | null
    sheetRowIndex?: IntFilter<"Applicant"> | number
    lastUpdated?: DateTimeFilter<"Applicant"> | Date | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    campaignId?: StringFilter<"Applicant"> | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    snsProfiles?: SNSProfileListRelationFilter
    selectionResults?: SelectionResultListRelationFilter
    mailHistories?: MailHistoryListRelationFilter
  }

  export type ApplicantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    applicationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    sheetRowIndex?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    campaignId?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    snsProfiles?: SNSProfileOrderByRelationAggregateInput
    selectionResults?: SelectionResultOrderByRelationAggregateInput
    mailHistories?: MailHistoryOrderByRelationAggregateInput
  }

  export type ApplicantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_email?: ApplicantCampaignIdEmailCompoundUniqueInput
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    name?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    phone?: StringNullableFilter<"Applicant"> | string | null
    applicationDate?: DateTimeFilter<"Applicant"> | Date | string
    status?: EnumApplicantStatusFilter<"Applicant"> | $Enums.ApplicantStatus
    notes?: StringNullableFilter<"Applicant"> | string | null
    sheetRowIndex?: IntFilter<"Applicant"> | number
    lastUpdated?: DateTimeFilter<"Applicant"> | Date | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    campaignId?: StringFilter<"Applicant"> | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    snsProfiles?: SNSProfileListRelationFilter
    selectionResults?: SelectionResultListRelationFilter
    mailHistories?: MailHistoryListRelationFilter
  }, "id" | "campaignId_email">

  export type ApplicantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    applicationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    sheetRowIndex?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    campaignId?: SortOrder
    _count?: ApplicantCountOrderByAggregateInput
    _avg?: ApplicantAvgOrderByAggregateInput
    _max?: ApplicantMaxOrderByAggregateInput
    _min?: ApplicantMinOrderByAggregateInput
    _sum?: ApplicantSumOrderByAggregateInput
  }

  export type ApplicantScalarWhereWithAggregatesInput = {
    AND?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    OR?: ApplicantScalarWhereWithAggregatesInput[]
    NOT?: ApplicantScalarWhereWithAggregatesInput | ApplicantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Applicant"> | string
    name?: StringWithAggregatesFilter<"Applicant"> | string
    email?: StringWithAggregatesFilter<"Applicant"> | string
    phone?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    applicationDate?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    status?: EnumApplicantStatusWithAggregatesFilter<"Applicant"> | $Enums.ApplicantStatus
    notes?: StringNullableWithAggregatesFilter<"Applicant"> | string | null
    sheetRowIndex?: IntWithAggregatesFilter<"Applicant"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Applicant"> | Date | string
    campaignId?: StringWithAggregatesFilter<"Applicant"> | string
  }

  export type SNSProfileWhereInput = {
    AND?: SNSProfileWhereInput | SNSProfileWhereInput[]
    OR?: SNSProfileWhereInput[]
    NOT?: SNSProfileWhereInput | SNSProfileWhereInput[]
    id?: StringFilter<"SNSProfile"> | string
    platform?: EnumSNSPlatformFilter<"SNSProfile"> | $Enums.SNSPlatform
    url?: StringFilter<"SNSProfile"> | string
    handle?: StringNullableFilter<"SNSProfile"> | string | null
    followers?: IntNullableFilter<"SNSProfile"> | number | null
    visitors?: IntNullableFilter<"SNSProfile"> | number | null
    isValid?: BoolFilter<"SNSProfile"> | boolean
    createdAt?: DateTimeFilter<"SNSProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SNSProfile"> | Date | string
    applicantId?: StringFilter<"SNSProfile"> | string
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
  }

  export type SNSProfileOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    handle?: SortOrderInput | SortOrder
    followers?: SortOrderInput | SortOrder
    visitors?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    applicant?: ApplicantOrderByWithRelationInput
  }

  export type SNSProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SNSProfileWhereInput | SNSProfileWhereInput[]
    OR?: SNSProfileWhereInput[]
    NOT?: SNSProfileWhereInput | SNSProfileWhereInput[]
    platform?: EnumSNSPlatformFilter<"SNSProfile"> | $Enums.SNSPlatform
    url?: StringFilter<"SNSProfile"> | string
    handle?: StringNullableFilter<"SNSProfile"> | string | null
    followers?: IntNullableFilter<"SNSProfile"> | number | null
    visitors?: IntNullableFilter<"SNSProfile"> | number | null
    isValid?: BoolFilter<"SNSProfile"> | boolean
    createdAt?: DateTimeFilter<"SNSProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SNSProfile"> | Date | string
    applicantId?: StringFilter<"SNSProfile"> | string
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
  }, "id">

  export type SNSProfileOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    handle?: SortOrderInput | SortOrder
    followers?: SortOrderInput | SortOrder
    visitors?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    _count?: SNSProfileCountOrderByAggregateInput
    _avg?: SNSProfileAvgOrderByAggregateInput
    _max?: SNSProfileMaxOrderByAggregateInput
    _min?: SNSProfileMinOrderByAggregateInput
    _sum?: SNSProfileSumOrderByAggregateInput
  }

  export type SNSProfileScalarWhereWithAggregatesInput = {
    AND?: SNSProfileScalarWhereWithAggregatesInput | SNSProfileScalarWhereWithAggregatesInput[]
    OR?: SNSProfileScalarWhereWithAggregatesInput[]
    NOT?: SNSProfileScalarWhereWithAggregatesInput | SNSProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SNSProfile"> | string
    platform?: EnumSNSPlatformWithAggregatesFilter<"SNSProfile"> | $Enums.SNSPlatform
    url?: StringWithAggregatesFilter<"SNSProfile"> | string
    handle?: StringNullableWithAggregatesFilter<"SNSProfile"> | string | null
    followers?: IntNullableWithAggregatesFilter<"SNSProfile"> | number | null
    visitors?: IntNullableWithAggregatesFilter<"SNSProfile"> | number | null
    isValid?: BoolWithAggregatesFilter<"SNSProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SNSProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SNSProfile"> | Date | string
    applicantId?: StringWithAggregatesFilter<"SNSProfile"> | string
  }

  export type SelectionResultWhereInput = {
    AND?: SelectionResultWhereInput | SelectionResultWhereInput[]
    OR?: SelectionResultWhereInput[]
    NOT?: SelectionResultWhereInput | SelectionResultWhereInput[]
    id?: StringFilter<"SelectionResult"> | string
    isSelected?: BoolFilter<"SelectionResult"> | boolean
    selectionReason?: StringFilter<"SelectionResult"> | string
    selectionDate?: DateTimeFilter<"SelectionResult"> | Date | string
    qualifyingPlatforms?: JsonFilter<"SelectionResult">
    processingStatus?: EnumProcessingStatusFilter<"SelectionResult"> | $Enums.ProcessingStatus
    sheetUpdated?: BoolFilter<"SelectionResult"> | boolean
    sheetUpdateDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    emailSent?: BoolFilter<"SelectionResult"> | boolean
    emailSentDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SelectionResult"> | Date | string
    updatedAt?: DateTimeFilter<"SelectionResult"> | Date | string
    applicantId?: StringFilter<"SelectionResult"> | string
    campaignId?: StringFilter<"SelectionResult"> | string
    meetsCriteria?: JsonFilter<"SelectionResult">
    snsDataSnapshot?: JsonFilter<"SelectionResult">
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type SelectionResultOrderByWithRelationInput = {
    id?: SortOrder
    isSelected?: SortOrder
    selectionReason?: SortOrder
    selectionDate?: SortOrder
    qualifyingPlatforms?: SortOrder
    processingStatus?: SortOrder
    sheetUpdated?: SortOrder
    sheetUpdateDate?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailSentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
    meetsCriteria?: SortOrder
    snsDataSnapshot?: SortOrder
    applicant?: ApplicantOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type SelectionResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicantId_campaignId?: SelectionResultApplicantIdCampaignIdCompoundUniqueInput
    AND?: SelectionResultWhereInput | SelectionResultWhereInput[]
    OR?: SelectionResultWhereInput[]
    NOT?: SelectionResultWhereInput | SelectionResultWhereInput[]
    isSelected?: BoolFilter<"SelectionResult"> | boolean
    selectionReason?: StringFilter<"SelectionResult"> | string
    selectionDate?: DateTimeFilter<"SelectionResult"> | Date | string
    qualifyingPlatforms?: JsonFilter<"SelectionResult">
    processingStatus?: EnumProcessingStatusFilter<"SelectionResult"> | $Enums.ProcessingStatus
    sheetUpdated?: BoolFilter<"SelectionResult"> | boolean
    sheetUpdateDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    emailSent?: BoolFilter<"SelectionResult"> | boolean
    emailSentDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SelectionResult"> | Date | string
    updatedAt?: DateTimeFilter<"SelectionResult"> | Date | string
    applicantId?: StringFilter<"SelectionResult"> | string
    campaignId?: StringFilter<"SelectionResult"> | string
    meetsCriteria?: JsonFilter<"SelectionResult">
    snsDataSnapshot?: JsonFilter<"SelectionResult">
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "applicantId_campaignId">

  export type SelectionResultOrderByWithAggregationInput = {
    id?: SortOrder
    isSelected?: SortOrder
    selectionReason?: SortOrder
    selectionDate?: SortOrder
    qualifyingPlatforms?: SortOrder
    processingStatus?: SortOrder
    sheetUpdated?: SortOrder
    sheetUpdateDate?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailSentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
    meetsCriteria?: SortOrder
    snsDataSnapshot?: SortOrder
    _count?: SelectionResultCountOrderByAggregateInput
    _max?: SelectionResultMaxOrderByAggregateInput
    _min?: SelectionResultMinOrderByAggregateInput
  }

  export type SelectionResultScalarWhereWithAggregatesInput = {
    AND?: SelectionResultScalarWhereWithAggregatesInput | SelectionResultScalarWhereWithAggregatesInput[]
    OR?: SelectionResultScalarWhereWithAggregatesInput[]
    NOT?: SelectionResultScalarWhereWithAggregatesInput | SelectionResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SelectionResult"> | string
    isSelected?: BoolWithAggregatesFilter<"SelectionResult"> | boolean
    selectionReason?: StringWithAggregatesFilter<"SelectionResult"> | string
    selectionDate?: DateTimeWithAggregatesFilter<"SelectionResult"> | Date | string
    qualifyingPlatforms?: JsonWithAggregatesFilter<"SelectionResult">
    processingStatus?: EnumProcessingStatusWithAggregatesFilter<"SelectionResult"> | $Enums.ProcessingStatus
    sheetUpdated?: BoolWithAggregatesFilter<"SelectionResult"> | boolean
    sheetUpdateDate?: DateTimeNullableWithAggregatesFilter<"SelectionResult"> | Date | string | null
    emailSent?: BoolWithAggregatesFilter<"SelectionResult"> | boolean
    emailSentDate?: DateTimeNullableWithAggregatesFilter<"SelectionResult"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SelectionResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SelectionResult"> | Date | string
    applicantId?: StringWithAggregatesFilter<"SelectionResult"> | string
    campaignId?: StringWithAggregatesFilter<"SelectionResult"> | string
    meetsCriteria?: JsonWithAggregatesFilter<"SelectionResult">
    snsDataSnapshot?: JsonWithAggregatesFilter<"SelectionResult">
  }

  export type MailHistoryWhereInput = {
    AND?: MailHistoryWhereInput | MailHistoryWhereInput[]
    OR?: MailHistoryWhereInput[]
    NOT?: MailHistoryWhereInput | MailHistoryWhereInput[]
    id?: StringFilter<"MailHistory"> | string
    mailType?: EnumMailTypeFilter<"MailHistory"> | $Enums.MailType
    recipient?: StringFilter<"MailHistory"> | string
    subject?: StringFilter<"MailHistory"> | string
    content?: StringFilter<"MailHistory"> | string
    status?: EnumMailStatusFilter<"MailHistory"> | $Enums.MailStatus
    sentAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    failReason?: StringNullableFilter<"MailHistory"> | string | null
    scheduledAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"MailHistory"> | Date | string
    updatedAt?: DateTimeFilter<"MailHistory"> | Date | string
    applicantId?: StringFilter<"MailHistory"> | string
    campaignId?: StringFilter<"MailHistory"> | string
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type MailHistoryOrderByWithRelationInput = {
    id?: SortOrder
    mailType?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    failReason?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
    applicant?: ApplicantOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type MailHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MailHistoryWhereInput | MailHistoryWhereInput[]
    OR?: MailHistoryWhereInput[]
    NOT?: MailHistoryWhereInput | MailHistoryWhereInput[]
    mailType?: EnumMailTypeFilter<"MailHistory"> | $Enums.MailType
    recipient?: StringFilter<"MailHistory"> | string
    subject?: StringFilter<"MailHistory"> | string
    content?: StringFilter<"MailHistory"> | string
    status?: EnumMailStatusFilter<"MailHistory"> | $Enums.MailStatus
    sentAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    failReason?: StringNullableFilter<"MailHistory"> | string | null
    scheduledAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"MailHistory"> | Date | string
    updatedAt?: DateTimeFilter<"MailHistory"> | Date | string
    applicantId?: StringFilter<"MailHistory"> | string
    campaignId?: StringFilter<"MailHistory"> | string
    applicant?: XOR<ApplicantScalarRelationFilter, ApplicantWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type MailHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    mailType?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    failReason?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
    _count?: MailHistoryCountOrderByAggregateInput
    _max?: MailHistoryMaxOrderByAggregateInput
    _min?: MailHistoryMinOrderByAggregateInput
  }

  export type MailHistoryScalarWhereWithAggregatesInput = {
    AND?: MailHistoryScalarWhereWithAggregatesInput | MailHistoryScalarWhereWithAggregatesInput[]
    OR?: MailHistoryScalarWhereWithAggregatesInput[]
    NOT?: MailHistoryScalarWhereWithAggregatesInput | MailHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MailHistory"> | string
    mailType?: EnumMailTypeWithAggregatesFilter<"MailHistory"> | $Enums.MailType
    recipient?: StringWithAggregatesFilter<"MailHistory"> | string
    subject?: StringWithAggregatesFilter<"MailHistory"> | string
    content?: StringWithAggregatesFilter<"MailHistory"> | string
    status?: EnumMailStatusWithAggregatesFilter<"MailHistory"> | $Enums.MailStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"MailHistory"> | Date | string | null
    failReason?: StringNullableWithAggregatesFilter<"MailHistory"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"MailHistory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MailHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MailHistory"> | Date | string
    applicantId?: StringWithAggregatesFilter<"MailHistory"> | string
    campaignId?: StringWithAggregatesFilter<"MailHistory"> | string
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    success?: BoolFilter<"SyncLog"> | boolean
    newApplicants?: IntFilter<"SyncLog"> | number
    updatedApplicants?: IntFilter<"SyncLog"> | number
    errors?: JsonFilter<"SyncLog">
    lastSyncTime?: DateTimeFilter<"SyncLog"> | Date | string
    createdAt?: DateTimeFilter<"SyncLog"> | Date | string
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    success?: SortOrder
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
    errors?: SortOrder
    lastSyncTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    success?: BoolFilter<"SyncLog"> | boolean
    newApplicants?: IntFilter<"SyncLog"> | number
    updatedApplicants?: IntFilter<"SyncLog"> | number
    errors?: JsonFilter<"SyncLog">
    lastSyncTime?: DateTimeFilter<"SyncLog"> | Date | string
    createdAt?: DateTimeFilter<"SyncLog"> | Date | string
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    success?: SortOrder
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
    errors?: SortOrder
    lastSyncTime?: SortOrder
    createdAt?: SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    success?: BoolWithAggregatesFilter<"SyncLog"> | boolean
    newApplicants?: IntWithAggregatesFilter<"SyncLog"> | number
    updatedApplicants?: IntWithAggregatesFilter<"SyncLog"> | number
    errors?: JsonWithAggregatesFilter<"SyncLog">
    lastSyncTime?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    applicants?: ApplicantCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    applicants?: ApplicantUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUncheckedUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicantCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutApplicantsInput
    snsProfiles?: SNSProfileCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaignId: string
    snsProfiles?: SNSProfileUncheckedCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutApplicantsNestedInput
    snsProfiles?: SNSProfileUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    snsProfiles?: SNSProfileUncheckedUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaignId: string
  }

  export type ApplicantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type SNSProfileCreateInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutSnsProfilesInput
  }

  export type SNSProfileUncheckedCreateInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
  }

  export type SNSProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutSnsProfilesNestedInput
  }

  export type SNSProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
  }

  export type SNSProfileCreateManyInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
  }

  export type SNSProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SNSProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
  }

  export type SelectionResultCreateInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
    applicant: ApplicantCreateNestedOneWithoutSelectionResultsInput
    campaign: CampaignCreateNestedOneWithoutSelectionResultsInput
  }

  export type SelectionResultUncheckedCreateInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    campaignId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
    applicant?: ApplicantUpdateOneRequiredWithoutSelectionResultsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutSelectionResultsNestedInput
  }

  export type SelectionResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultCreateManyInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    campaignId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type MailHistoryCreateInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutMailHistoriesInput
    campaign: CampaignCreateNestedOneWithoutMailHistoriesInput
  }

  export type MailHistoryUncheckedCreateInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    campaignId: string
  }

  export type MailHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutMailHistoriesNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutMailHistoriesNestedInput
  }

  export type MailHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type MailHistoryCreateManyInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    campaignId: string
  }

  export type MailHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncLogCreateInput = {
    id?: string
    success: boolean
    newApplicants?: number
    updatedApplicants?: number
    errors: JsonNullValueInput | InputJsonValue
    lastSyncTime?: Date | string
    createdAt?: Date | string
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    success: boolean
    newApplicants?: number
    updatedApplicants?: number
    errors: JsonNullValueInput | InputJsonValue
    lastSyncTime?: Date | string
    createdAt?: Date | string
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    newApplicants?: IntFieldUpdateOperationsInput | number
    updatedApplicants?: IntFieldUpdateOperationsInput | number
    errors?: JsonNullValueInput | InputJsonValue
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    newApplicants?: IntFieldUpdateOperationsInput | number
    updatedApplicants?: IntFieldUpdateOperationsInput | number
    errors?: JsonNullValueInput | InputJsonValue
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateManyInput = {
    id?: string
    success: boolean
    newApplicants?: number
    updatedApplicants?: number
    errors: JsonNullValueInput | InputJsonValue
    lastSyncTime?: Date | string
    createdAt?: Date | string
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    newApplicants?: IntFieldUpdateOperationsInput | number
    updatedApplicants?: IntFieldUpdateOperationsInput | number
    errors?: JsonNullValueInput | InputJsonValue
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    newApplicants?: IntFieldUpdateOperationsInput | number
    updatedApplicants?: IntFieldUpdateOperationsInput | number
    errors?: JsonNullValueInput | InputJsonValue
    lastSyncTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ApplicantListRelationFilter = {
    every?: ApplicantWhereInput
    some?: ApplicantWhereInput
    none?: ApplicantWhereInput
  }

  export type SelectionResultListRelationFilter = {
    every?: SelectionResultWhereInput
    some?: SelectionResultWhereInput
    none?: SelectionResultWhereInput
  }

  export type MailHistoryListRelationFilter = {
    every?: MailHistoryWhereInput
    some?: MailHistoryWhereInput
    none?: MailHistoryWhereInput
  }

  export type ApplicantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SelectionResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MailHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sheetId?: SortOrder
    sheetName?: SortOrder
    sheetUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sheetId?: SortOrder
    sheetName?: SortOrder
    sheetUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sheetId?: SortOrder
    sheetName?: SortOrder
    sheetUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumApplicantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantStatus | EnumApplicantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantStatusFilter<$PrismaModel> | $Enums.ApplicantStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type SNSProfileListRelationFilter = {
    every?: SNSProfileWhereInput
    some?: SNSProfileWhereInput
    none?: SNSProfileWhereInput
  }

  export type SNSProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicantCampaignIdEmailCompoundUniqueInput = {
    campaignId: string
    email: string
  }

  export type ApplicantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    applicationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sheetRowIndex?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    campaignId?: SortOrder
  }

  export type ApplicantAvgOrderByAggregateInput = {
    sheetRowIndex?: SortOrder
  }

  export type ApplicantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    applicationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sheetRowIndex?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    campaignId?: SortOrder
  }

  export type ApplicantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    applicationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sheetRowIndex?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    campaignId?: SortOrder
  }

  export type ApplicantSumOrderByAggregateInput = {
    sheetRowIndex?: SortOrder
  }

  export type EnumApplicantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantStatus | EnumApplicantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicantStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSNSPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SNSPlatform | EnumSNSPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSNSPlatformFilter<$PrismaModel> | $Enums.SNSPlatform
  }

  export type ApplicantScalarRelationFilter = {
    is?: ApplicantWhereInput
    isNot?: ApplicantWhereInput
  }

  export type SNSProfileCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    handle?: SortOrder
    followers?: SortOrder
    visitors?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
  }

  export type SNSProfileAvgOrderByAggregateInput = {
    followers?: SortOrder
    visitors?: SortOrder
  }

  export type SNSProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    handle?: SortOrder
    followers?: SortOrder
    visitors?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
  }

  export type SNSProfileMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    handle?: SortOrder
    followers?: SortOrder
    visitors?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
  }

  export type SNSProfileSumOrderByAggregateInput = {
    followers?: SortOrder
    visitors?: SortOrder
  }

  export type EnumSNSPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SNSPlatform | EnumSNSPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSNSPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SNSPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSNSPlatformFilter<$PrismaModel>
    _max?: NestedEnumSNSPlatformFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type SelectionResultApplicantIdCampaignIdCompoundUniqueInput = {
    applicantId: string
    campaignId: string
  }

  export type SelectionResultCountOrderByAggregateInput = {
    id?: SortOrder
    isSelected?: SortOrder
    selectionReason?: SortOrder
    selectionDate?: SortOrder
    qualifyingPlatforms?: SortOrder
    processingStatus?: SortOrder
    sheetUpdated?: SortOrder
    sheetUpdateDate?: SortOrder
    emailSent?: SortOrder
    emailSentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
    meetsCriteria?: SortOrder
    snsDataSnapshot?: SortOrder
  }

  export type SelectionResultMaxOrderByAggregateInput = {
    id?: SortOrder
    isSelected?: SortOrder
    selectionReason?: SortOrder
    selectionDate?: SortOrder
    processingStatus?: SortOrder
    sheetUpdated?: SortOrder
    sheetUpdateDate?: SortOrder
    emailSent?: SortOrder
    emailSentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
  }

  export type SelectionResultMinOrderByAggregateInput = {
    id?: SortOrder
    isSelected?: SortOrder
    selectionReason?: SortOrder
    selectionDate?: SortOrder
    processingStatus?: SortOrder
    sheetUpdated?: SortOrder
    sheetUpdateDate?: SortOrder
    emailSent?: SortOrder
    emailSentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type EnumMailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeFilter<$PrismaModel> | $Enums.MailType
  }

  export type EnumMailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusFilter<$PrismaModel> | $Enums.MailStatus
  }

  export type MailHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    mailType?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failReason?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
  }

  export type MailHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    mailType?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failReason?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
  }

  export type MailHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    mailType?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failReason?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantId?: SortOrder
    campaignId?: SortOrder
  }

  export type EnumMailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeWithAggregatesFilter<$PrismaModel> | $Enums.MailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailTypeFilter<$PrismaModel>
    _max?: NestedEnumMailTypeFilter<$PrismaModel>
  }

  export type EnumMailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailStatusFilter<$PrismaModel>
    _max?: NestedEnumMailStatusFilter<$PrismaModel>
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    success?: SortOrder
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
    errors?: SortOrder
    lastSyncTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    success?: SortOrder
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
    lastSyncTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    success?: SortOrder
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
    lastSyncTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    newApplicants?: SortOrder
    updatedApplicants?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicantCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput> | ApplicantCreateWithoutCampaignInput[] | ApplicantUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutCampaignInput | ApplicantCreateOrConnectWithoutCampaignInput[]
    createMany?: ApplicantCreateManyCampaignInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type SelectionResultCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput> | SelectionResultCreateWithoutCampaignInput[] | SelectionResultUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutCampaignInput | SelectionResultCreateOrConnectWithoutCampaignInput[]
    createMany?: SelectionResultCreateManyCampaignInputEnvelope
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
  }

  export type MailHistoryCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput> | MailHistoryCreateWithoutCampaignInput[] | MailHistoryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutCampaignInput | MailHistoryCreateOrConnectWithoutCampaignInput[]
    createMany?: MailHistoryCreateManyCampaignInputEnvelope
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
  }

  export type ApplicantUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput> | ApplicantCreateWithoutCampaignInput[] | ApplicantUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutCampaignInput | ApplicantCreateOrConnectWithoutCampaignInput[]
    createMany?: ApplicantCreateManyCampaignInputEnvelope
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
  }

  export type SelectionResultUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput> | SelectionResultCreateWithoutCampaignInput[] | SelectionResultUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutCampaignInput | SelectionResultCreateOrConnectWithoutCampaignInput[]
    createMany?: SelectionResultCreateManyCampaignInputEnvelope
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
  }

  export type MailHistoryUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput> | MailHistoryCreateWithoutCampaignInput[] | MailHistoryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutCampaignInput | MailHistoryCreateOrConnectWithoutCampaignInput[]
    createMany?: MailHistoryCreateManyCampaignInputEnvelope
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type ApplicantUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput> | ApplicantCreateWithoutCampaignInput[] | ApplicantUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutCampaignInput | ApplicantCreateOrConnectWithoutCampaignInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutCampaignInput | ApplicantUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ApplicantCreateManyCampaignInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutCampaignInput | ApplicantUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutCampaignInput | ApplicantUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type SelectionResultUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput> | SelectionResultCreateWithoutCampaignInput[] | SelectionResultUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutCampaignInput | SelectionResultCreateOrConnectWithoutCampaignInput[]
    upsert?: SelectionResultUpsertWithWhereUniqueWithoutCampaignInput | SelectionResultUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SelectionResultCreateManyCampaignInputEnvelope
    set?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    disconnect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    delete?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    update?: SelectionResultUpdateWithWhereUniqueWithoutCampaignInput | SelectionResultUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SelectionResultUpdateManyWithWhereWithoutCampaignInput | SelectionResultUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
  }

  export type MailHistoryUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput> | MailHistoryCreateWithoutCampaignInput[] | MailHistoryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutCampaignInput | MailHistoryCreateOrConnectWithoutCampaignInput[]
    upsert?: MailHistoryUpsertWithWhereUniqueWithoutCampaignInput | MailHistoryUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MailHistoryCreateManyCampaignInputEnvelope
    set?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    disconnect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    delete?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    update?: MailHistoryUpdateWithWhereUniqueWithoutCampaignInput | MailHistoryUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MailHistoryUpdateManyWithWhereWithoutCampaignInput | MailHistoryUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
  }

  export type ApplicantUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput> | ApplicantCreateWithoutCampaignInput[] | ApplicantUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ApplicantCreateOrConnectWithoutCampaignInput | ApplicantCreateOrConnectWithoutCampaignInput[]
    upsert?: ApplicantUpsertWithWhereUniqueWithoutCampaignInput | ApplicantUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ApplicantCreateManyCampaignInputEnvelope
    set?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    disconnect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    delete?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    connect?: ApplicantWhereUniqueInput | ApplicantWhereUniqueInput[]
    update?: ApplicantUpdateWithWhereUniqueWithoutCampaignInput | ApplicantUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ApplicantUpdateManyWithWhereWithoutCampaignInput | ApplicantUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
  }

  export type SelectionResultUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput> | SelectionResultCreateWithoutCampaignInput[] | SelectionResultUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutCampaignInput | SelectionResultCreateOrConnectWithoutCampaignInput[]
    upsert?: SelectionResultUpsertWithWhereUniqueWithoutCampaignInput | SelectionResultUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SelectionResultCreateManyCampaignInputEnvelope
    set?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    disconnect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    delete?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    update?: SelectionResultUpdateWithWhereUniqueWithoutCampaignInput | SelectionResultUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SelectionResultUpdateManyWithWhereWithoutCampaignInput | SelectionResultUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
  }

  export type MailHistoryUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput> | MailHistoryCreateWithoutCampaignInput[] | MailHistoryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutCampaignInput | MailHistoryCreateOrConnectWithoutCampaignInput[]
    upsert?: MailHistoryUpsertWithWhereUniqueWithoutCampaignInput | MailHistoryUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MailHistoryCreateManyCampaignInputEnvelope
    set?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    disconnect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    delete?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    update?: MailHistoryUpdateWithWhereUniqueWithoutCampaignInput | MailHistoryUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MailHistoryUpdateManyWithWhereWithoutCampaignInput | MailHistoryUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<CampaignCreateWithoutApplicantsInput, CampaignUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutApplicantsInput
    connect?: CampaignWhereUniqueInput
  }

  export type SNSProfileCreateNestedManyWithoutApplicantInput = {
    create?: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput> | SNSProfileCreateWithoutApplicantInput[] | SNSProfileUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SNSProfileCreateOrConnectWithoutApplicantInput | SNSProfileCreateOrConnectWithoutApplicantInput[]
    createMany?: SNSProfileCreateManyApplicantInputEnvelope
    connect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
  }

  export type SelectionResultCreateNestedManyWithoutApplicantInput = {
    create?: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput> | SelectionResultCreateWithoutApplicantInput[] | SelectionResultUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutApplicantInput | SelectionResultCreateOrConnectWithoutApplicantInput[]
    createMany?: SelectionResultCreateManyApplicantInputEnvelope
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
  }

  export type MailHistoryCreateNestedManyWithoutApplicantInput = {
    create?: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput> | MailHistoryCreateWithoutApplicantInput[] | MailHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutApplicantInput | MailHistoryCreateOrConnectWithoutApplicantInput[]
    createMany?: MailHistoryCreateManyApplicantInputEnvelope
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
  }

  export type SNSProfileUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput> | SNSProfileCreateWithoutApplicantInput[] | SNSProfileUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SNSProfileCreateOrConnectWithoutApplicantInput | SNSProfileCreateOrConnectWithoutApplicantInput[]
    createMany?: SNSProfileCreateManyApplicantInputEnvelope
    connect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
  }

  export type SelectionResultUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput> | SelectionResultCreateWithoutApplicantInput[] | SelectionResultUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutApplicantInput | SelectionResultCreateOrConnectWithoutApplicantInput[]
    createMany?: SelectionResultCreateManyApplicantInputEnvelope
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
  }

  export type MailHistoryUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput> | MailHistoryCreateWithoutApplicantInput[] | MailHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutApplicantInput | MailHistoryCreateOrConnectWithoutApplicantInput[]
    createMany?: MailHistoryCreateManyApplicantInputEnvelope
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
  }

  export type EnumApplicantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicantStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutApplicantsNestedInput = {
    create?: XOR<CampaignCreateWithoutApplicantsInput, CampaignUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutApplicantsInput
    upsert?: CampaignUpsertWithoutApplicantsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutApplicantsInput, CampaignUpdateWithoutApplicantsInput>, CampaignUncheckedUpdateWithoutApplicantsInput>
  }

  export type SNSProfileUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput> | SNSProfileCreateWithoutApplicantInput[] | SNSProfileUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SNSProfileCreateOrConnectWithoutApplicantInput | SNSProfileCreateOrConnectWithoutApplicantInput[]
    upsert?: SNSProfileUpsertWithWhereUniqueWithoutApplicantInput | SNSProfileUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: SNSProfileCreateManyApplicantInputEnvelope
    set?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    disconnect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    delete?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    connect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    update?: SNSProfileUpdateWithWhereUniqueWithoutApplicantInput | SNSProfileUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: SNSProfileUpdateManyWithWhereWithoutApplicantInput | SNSProfileUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: SNSProfileScalarWhereInput | SNSProfileScalarWhereInput[]
  }

  export type SelectionResultUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput> | SelectionResultCreateWithoutApplicantInput[] | SelectionResultUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutApplicantInput | SelectionResultCreateOrConnectWithoutApplicantInput[]
    upsert?: SelectionResultUpsertWithWhereUniqueWithoutApplicantInput | SelectionResultUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: SelectionResultCreateManyApplicantInputEnvelope
    set?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    disconnect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    delete?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    update?: SelectionResultUpdateWithWhereUniqueWithoutApplicantInput | SelectionResultUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: SelectionResultUpdateManyWithWhereWithoutApplicantInput | SelectionResultUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
  }

  export type MailHistoryUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput> | MailHistoryCreateWithoutApplicantInput[] | MailHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutApplicantInput | MailHistoryCreateOrConnectWithoutApplicantInput[]
    upsert?: MailHistoryUpsertWithWhereUniqueWithoutApplicantInput | MailHistoryUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: MailHistoryCreateManyApplicantInputEnvelope
    set?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    disconnect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    delete?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    update?: MailHistoryUpdateWithWhereUniqueWithoutApplicantInput | MailHistoryUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: MailHistoryUpdateManyWithWhereWithoutApplicantInput | MailHistoryUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
  }

  export type SNSProfileUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput> | SNSProfileCreateWithoutApplicantInput[] | SNSProfileUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SNSProfileCreateOrConnectWithoutApplicantInput | SNSProfileCreateOrConnectWithoutApplicantInput[]
    upsert?: SNSProfileUpsertWithWhereUniqueWithoutApplicantInput | SNSProfileUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: SNSProfileCreateManyApplicantInputEnvelope
    set?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    disconnect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    delete?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    connect?: SNSProfileWhereUniqueInput | SNSProfileWhereUniqueInput[]
    update?: SNSProfileUpdateWithWhereUniqueWithoutApplicantInput | SNSProfileUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: SNSProfileUpdateManyWithWhereWithoutApplicantInput | SNSProfileUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: SNSProfileScalarWhereInput | SNSProfileScalarWhereInput[]
  }

  export type SelectionResultUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput> | SelectionResultCreateWithoutApplicantInput[] | SelectionResultUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: SelectionResultCreateOrConnectWithoutApplicantInput | SelectionResultCreateOrConnectWithoutApplicantInput[]
    upsert?: SelectionResultUpsertWithWhereUniqueWithoutApplicantInput | SelectionResultUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: SelectionResultCreateManyApplicantInputEnvelope
    set?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    disconnect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    delete?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    connect?: SelectionResultWhereUniqueInput | SelectionResultWhereUniqueInput[]
    update?: SelectionResultUpdateWithWhereUniqueWithoutApplicantInput | SelectionResultUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: SelectionResultUpdateManyWithWhereWithoutApplicantInput | SelectionResultUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
  }

  export type MailHistoryUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput> | MailHistoryCreateWithoutApplicantInput[] | MailHistoryUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: MailHistoryCreateOrConnectWithoutApplicantInput | MailHistoryCreateOrConnectWithoutApplicantInput[]
    upsert?: MailHistoryUpsertWithWhereUniqueWithoutApplicantInput | MailHistoryUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: MailHistoryCreateManyApplicantInputEnvelope
    set?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    disconnect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    delete?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    connect?: MailHistoryWhereUniqueInput | MailHistoryWhereUniqueInput[]
    update?: MailHistoryUpdateWithWhereUniqueWithoutApplicantInput | MailHistoryUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: MailHistoryUpdateManyWithWhereWithoutApplicantInput | MailHistoryUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
  }

  export type ApplicantCreateNestedOneWithoutSnsProfilesInput = {
    create?: XOR<ApplicantCreateWithoutSnsProfilesInput, ApplicantUncheckedCreateWithoutSnsProfilesInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutSnsProfilesInput
    connect?: ApplicantWhereUniqueInput
  }

  export type EnumSNSPlatformFieldUpdateOperationsInput = {
    set?: $Enums.SNSPlatform
  }

  export type ApplicantUpdateOneRequiredWithoutSnsProfilesNestedInput = {
    create?: XOR<ApplicantCreateWithoutSnsProfilesInput, ApplicantUncheckedCreateWithoutSnsProfilesInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutSnsProfilesInput
    upsert?: ApplicantUpsertWithoutSnsProfilesInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutSnsProfilesInput, ApplicantUpdateWithoutSnsProfilesInput>, ApplicantUncheckedUpdateWithoutSnsProfilesInput>
  }

  export type ApplicantCreateNestedOneWithoutSelectionResultsInput = {
    create?: XOR<ApplicantCreateWithoutSelectionResultsInput, ApplicantUncheckedCreateWithoutSelectionResultsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutSelectionResultsInput
    connect?: ApplicantWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutSelectionResultsInput = {
    create?: XOR<CampaignCreateWithoutSelectionResultsInput, CampaignUncheckedCreateWithoutSelectionResultsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSelectionResultsInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type ApplicantUpdateOneRequiredWithoutSelectionResultsNestedInput = {
    create?: XOR<ApplicantCreateWithoutSelectionResultsInput, ApplicantUncheckedCreateWithoutSelectionResultsInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutSelectionResultsInput
    upsert?: ApplicantUpsertWithoutSelectionResultsInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutSelectionResultsInput, ApplicantUpdateWithoutSelectionResultsInput>, ApplicantUncheckedUpdateWithoutSelectionResultsInput>
  }

  export type CampaignUpdateOneRequiredWithoutSelectionResultsNestedInput = {
    create?: XOR<CampaignCreateWithoutSelectionResultsInput, CampaignUncheckedCreateWithoutSelectionResultsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSelectionResultsInput
    upsert?: CampaignUpsertWithoutSelectionResultsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSelectionResultsInput, CampaignUpdateWithoutSelectionResultsInput>, CampaignUncheckedUpdateWithoutSelectionResultsInput>
  }

  export type ApplicantCreateNestedOneWithoutMailHistoriesInput = {
    create?: XOR<ApplicantCreateWithoutMailHistoriesInput, ApplicantUncheckedCreateWithoutMailHistoriesInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutMailHistoriesInput
    connect?: ApplicantWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutMailHistoriesInput = {
    create?: XOR<CampaignCreateWithoutMailHistoriesInput, CampaignUncheckedCreateWithoutMailHistoriesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMailHistoriesInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumMailTypeFieldUpdateOperationsInput = {
    set?: $Enums.MailType
  }

  export type EnumMailStatusFieldUpdateOperationsInput = {
    set?: $Enums.MailStatus
  }

  export type ApplicantUpdateOneRequiredWithoutMailHistoriesNestedInput = {
    create?: XOR<ApplicantCreateWithoutMailHistoriesInput, ApplicantUncheckedCreateWithoutMailHistoriesInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutMailHistoriesInput
    upsert?: ApplicantUpsertWithoutMailHistoriesInput
    connect?: ApplicantWhereUniqueInput
    update?: XOR<XOR<ApplicantUpdateToOneWithWhereWithoutMailHistoriesInput, ApplicantUpdateWithoutMailHistoriesInput>, ApplicantUncheckedUpdateWithoutMailHistoriesInput>
  }

  export type CampaignUpdateOneRequiredWithoutMailHistoriesNestedInput = {
    create?: XOR<CampaignCreateWithoutMailHistoriesInput, CampaignUncheckedCreateWithoutMailHistoriesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMailHistoriesInput
    upsert?: CampaignUpsertWithoutMailHistoriesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMailHistoriesInput, CampaignUpdateWithoutMailHistoriesInput>, CampaignUncheckedUpdateWithoutMailHistoriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumApplicantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantStatus | EnumApplicantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantStatusFilter<$PrismaModel> | $Enums.ApplicantStatus
  }

  export type NestedEnumApplicantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantStatus | EnumApplicantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantStatus[] | ListEnumApplicantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicantStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSNSPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SNSPlatform | EnumSNSPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSNSPlatformFilter<$PrismaModel> | $Enums.SNSPlatform
  }

  export type NestedEnumSNSPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SNSPlatform | EnumSNSPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SNSPlatform[] | ListEnumSNSPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSNSPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SNSPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSNSPlatformFilter<$PrismaModel>
    _max?: NestedEnumSNSPlatformFilter<$PrismaModel>
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type NestedEnumMailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeFilter<$PrismaModel> | $Enums.MailType
  }

  export type NestedEnumMailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusFilter<$PrismaModel> | $Enums.MailStatus
  }

  export type NestedEnumMailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailType | EnumMailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailType[] | ListEnumMailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMailTypeWithAggregatesFilter<$PrismaModel> | $Enums.MailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailTypeFilter<$PrismaModel>
    _max?: NestedEnumMailTypeFilter<$PrismaModel>
  }

  export type NestedEnumMailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailStatus | EnumMailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailStatus[] | ListEnumMailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailStatusFilter<$PrismaModel>
    _max?: NestedEnumMailStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicants?: ApplicantCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    sheetId?: StringNullableFilter<"Campaign"> | string | null
    sheetName?: StringNullableFilter<"Campaign"> | string | null
    sheetUrl?: StringNullableFilter<"Campaign"> | string | null
    isActive?: BoolFilter<"Campaign"> | boolean
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    userId?: StringFilter<"Campaign"> | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    name?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type ApplicantCreateWithoutCampaignInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    snsProfiles?: SNSProfileCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    snsProfiles?: SNSProfileUncheckedCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutCampaignInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput>
  }

  export type ApplicantCreateManyCampaignInputEnvelope = {
    data: ApplicantCreateManyCampaignInput | ApplicantCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type SelectionResultCreateWithoutCampaignInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
    applicant: ApplicantCreateNestedOneWithoutSelectionResultsInput
  }

  export type SelectionResultUncheckedCreateWithoutCampaignInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultCreateOrConnectWithoutCampaignInput = {
    where: SelectionResultWhereUniqueInput
    create: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput>
  }

  export type SelectionResultCreateManyCampaignInputEnvelope = {
    data: SelectionResultCreateManyCampaignInput | SelectionResultCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type MailHistoryCreateWithoutCampaignInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant: ApplicantCreateNestedOneWithoutMailHistoriesInput
  }

  export type MailHistoryUncheckedCreateWithoutCampaignInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
  }

  export type MailHistoryCreateOrConnectWithoutCampaignInput = {
    where: MailHistoryWhereUniqueInput
    create: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput>
  }

  export type MailHistoryCreateManyCampaignInputEnvelope = {
    data: MailHistoryCreateManyCampaignInput | MailHistoryCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicantUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ApplicantWhereUniqueInput
    update: XOR<ApplicantUpdateWithoutCampaignInput, ApplicantUncheckedUpdateWithoutCampaignInput>
    create: XOR<ApplicantCreateWithoutCampaignInput, ApplicantUncheckedCreateWithoutCampaignInput>
  }

  export type ApplicantUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ApplicantWhereUniqueInput
    data: XOR<ApplicantUpdateWithoutCampaignInput, ApplicantUncheckedUpdateWithoutCampaignInput>
  }

  export type ApplicantUpdateManyWithWhereWithoutCampaignInput = {
    where: ApplicantScalarWhereInput
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ApplicantScalarWhereInput = {
    AND?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
    OR?: ApplicantScalarWhereInput[]
    NOT?: ApplicantScalarWhereInput | ApplicantScalarWhereInput[]
    id?: StringFilter<"Applicant"> | string
    name?: StringFilter<"Applicant"> | string
    email?: StringFilter<"Applicant"> | string
    phone?: StringNullableFilter<"Applicant"> | string | null
    applicationDate?: DateTimeFilter<"Applicant"> | Date | string
    status?: EnumApplicantStatusFilter<"Applicant"> | $Enums.ApplicantStatus
    notes?: StringNullableFilter<"Applicant"> | string | null
    sheetRowIndex?: IntFilter<"Applicant"> | number
    lastUpdated?: DateTimeFilter<"Applicant"> | Date | string
    createdAt?: DateTimeFilter<"Applicant"> | Date | string
    campaignId?: StringFilter<"Applicant"> | string
  }

  export type SelectionResultUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SelectionResultWhereUniqueInput
    update: XOR<SelectionResultUpdateWithoutCampaignInput, SelectionResultUncheckedUpdateWithoutCampaignInput>
    create: XOR<SelectionResultCreateWithoutCampaignInput, SelectionResultUncheckedCreateWithoutCampaignInput>
  }

  export type SelectionResultUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SelectionResultWhereUniqueInput
    data: XOR<SelectionResultUpdateWithoutCampaignInput, SelectionResultUncheckedUpdateWithoutCampaignInput>
  }

  export type SelectionResultUpdateManyWithWhereWithoutCampaignInput = {
    where: SelectionResultScalarWhereInput
    data: XOR<SelectionResultUpdateManyMutationInput, SelectionResultUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SelectionResultScalarWhereInput = {
    AND?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
    OR?: SelectionResultScalarWhereInput[]
    NOT?: SelectionResultScalarWhereInput | SelectionResultScalarWhereInput[]
    id?: StringFilter<"SelectionResult"> | string
    isSelected?: BoolFilter<"SelectionResult"> | boolean
    selectionReason?: StringFilter<"SelectionResult"> | string
    selectionDate?: DateTimeFilter<"SelectionResult"> | Date | string
    qualifyingPlatforms?: JsonFilter<"SelectionResult">
    processingStatus?: EnumProcessingStatusFilter<"SelectionResult"> | $Enums.ProcessingStatus
    sheetUpdated?: BoolFilter<"SelectionResult"> | boolean
    sheetUpdateDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    emailSent?: BoolFilter<"SelectionResult"> | boolean
    emailSentDate?: DateTimeNullableFilter<"SelectionResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SelectionResult"> | Date | string
    updatedAt?: DateTimeFilter<"SelectionResult"> | Date | string
    applicantId?: StringFilter<"SelectionResult"> | string
    campaignId?: StringFilter<"SelectionResult"> | string
    meetsCriteria?: JsonFilter<"SelectionResult">
    snsDataSnapshot?: JsonFilter<"SelectionResult">
  }

  export type MailHistoryUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MailHistoryWhereUniqueInput
    update: XOR<MailHistoryUpdateWithoutCampaignInput, MailHistoryUncheckedUpdateWithoutCampaignInput>
    create: XOR<MailHistoryCreateWithoutCampaignInput, MailHistoryUncheckedCreateWithoutCampaignInput>
  }

  export type MailHistoryUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MailHistoryWhereUniqueInput
    data: XOR<MailHistoryUpdateWithoutCampaignInput, MailHistoryUncheckedUpdateWithoutCampaignInput>
  }

  export type MailHistoryUpdateManyWithWhereWithoutCampaignInput = {
    where: MailHistoryScalarWhereInput
    data: XOR<MailHistoryUpdateManyMutationInput, MailHistoryUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MailHistoryScalarWhereInput = {
    AND?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
    OR?: MailHistoryScalarWhereInput[]
    NOT?: MailHistoryScalarWhereInput | MailHistoryScalarWhereInput[]
    id?: StringFilter<"MailHistory"> | string
    mailType?: EnumMailTypeFilter<"MailHistory"> | $Enums.MailType
    recipient?: StringFilter<"MailHistory"> | string
    subject?: StringFilter<"MailHistory"> | string
    content?: StringFilter<"MailHistory"> | string
    status?: EnumMailStatusFilter<"MailHistory"> | $Enums.MailStatus
    sentAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    failReason?: StringNullableFilter<"MailHistory"> | string | null
    scheduledAt?: DateTimeNullableFilter<"MailHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"MailHistory"> | Date | string
    updatedAt?: DateTimeFilter<"MailHistory"> | Date | string
    applicantId?: StringFilter<"MailHistory"> | string
    campaignId?: StringFilter<"MailHistory"> | string
  }

  export type CampaignCreateWithoutApplicantsInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    selectionResults?: SelectionResultCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutApplicantsInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutApplicantsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutApplicantsInput, CampaignUncheckedCreateWithoutApplicantsInput>
  }

  export type SNSProfileCreateWithoutApplicantInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SNSProfileUncheckedCreateWithoutApplicantInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SNSProfileCreateOrConnectWithoutApplicantInput = {
    where: SNSProfileWhereUniqueInput
    create: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput>
  }

  export type SNSProfileCreateManyApplicantInputEnvelope = {
    data: SNSProfileCreateManyApplicantInput | SNSProfileCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type SelectionResultCreateWithoutApplicantInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
    campaign: CampaignCreateNestedOneWithoutSelectionResultsInput
  }

  export type SelectionResultUncheckedCreateWithoutApplicantInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultCreateOrConnectWithoutApplicantInput = {
    where: SelectionResultWhereUniqueInput
    create: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput>
  }

  export type SelectionResultCreateManyApplicantInputEnvelope = {
    data: SelectionResultCreateManyApplicantInput | SelectionResultCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type MailHistoryCreateWithoutApplicantInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMailHistoriesInput
  }

  export type MailHistoryUncheckedCreateWithoutApplicantInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type MailHistoryCreateOrConnectWithoutApplicantInput = {
    where: MailHistoryWhereUniqueInput
    create: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput>
  }

  export type MailHistoryCreateManyApplicantInputEnvelope = {
    data: MailHistoryCreateManyApplicantInput | MailHistoryCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutApplicantsInput = {
    update: XOR<CampaignUpdateWithoutApplicantsInput, CampaignUncheckedUpdateWithoutApplicantsInput>
    create: XOR<CampaignCreateWithoutApplicantsInput, CampaignUncheckedCreateWithoutApplicantsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutApplicantsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutApplicantsInput, CampaignUncheckedUpdateWithoutApplicantsInput>
  }

  export type CampaignUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SNSProfileUpsertWithWhereUniqueWithoutApplicantInput = {
    where: SNSProfileWhereUniqueInput
    update: XOR<SNSProfileUpdateWithoutApplicantInput, SNSProfileUncheckedUpdateWithoutApplicantInput>
    create: XOR<SNSProfileCreateWithoutApplicantInput, SNSProfileUncheckedCreateWithoutApplicantInput>
  }

  export type SNSProfileUpdateWithWhereUniqueWithoutApplicantInput = {
    where: SNSProfileWhereUniqueInput
    data: XOR<SNSProfileUpdateWithoutApplicantInput, SNSProfileUncheckedUpdateWithoutApplicantInput>
  }

  export type SNSProfileUpdateManyWithWhereWithoutApplicantInput = {
    where: SNSProfileScalarWhereInput
    data: XOR<SNSProfileUpdateManyMutationInput, SNSProfileUncheckedUpdateManyWithoutApplicantInput>
  }

  export type SNSProfileScalarWhereInput = {
    AND?: SNSProfileScalarWhereInput | SNSProfileScalarWhereInput[]
    OR?: SNSProfileScalarWhereInput[]
    NOT?: SNSProfileScalarWhereInput | SNSProfileScalarWhereInput[]
    id?: StringFilter<"SNSProfile"> | string
    platform?: EnumSNSPlatformFilter<"SNSProfile"> | $Enums.SNSPlatform
    url?: StringFilter<"SNSProfile"> | string
    handle?: StringNullableFilter<"SNSProfile"> | string | null
    followers?: IntNullableFilter<"SNSProfile"> | number | null
    visitors?: IntNullableFilter<"SNSProfile"> | number | null
    isValid?: BoolFilter<"SNSProfile"> | boolean
    createdAt?: DateTimeFilter<"SNSProfile"> | Date | string
    updatedAt?: DateTimeFilter<"SNSProfile"> | Date | string
    applicantId?: StringFilter<"SNSProfile"> | string
  }

  export type SelectionResultUpsertWithWhereUniqueWithoutApplicantInput = {
    where: SelectionResultWhereUniqueInput
    update: XOR<SelectionResultUpdateWithoutApplicantInput, SelectionResultUncheckedUpdateWithoutApplicantInput>
    create: XOR<SelectionResultCreateWithoutApplicantInput, SelectionResultUncheckedCreateWithoutApplicantInput>
  }

  export type SelectionResultUpdateWithWhereUniqueWithoutApplicantInput = {
    where: SelectionResultWhereUniqueInput
    data: XOR<SelectionResultUpdateWithoutApplicantInput, SelectionResultUncheckedUpdateWithoutApplicantInput>
  }

  export type SelectionResultUpdateManyWithWhereWithoutApplicantInput = {
    where: SelectionResultScalarWhereInput
    data: XOR<SelectionResultUpdateManyMutationInput, SelectionResultUncheckedUpdateManyWithoutApplicantInput>
  }

  export type MailHistoryUpsertWithWhereUniqueWithoutApplicantInput = {
    where: MailHistoryWhereUniqueInput
    update: XOR<MailHistoryUpdateWithoutApplicantInput, MailHistoryUncheckedUpdateWithoutApplicantInput>
    create: XOR<MailHistoryCreateWithoutApplicantInput, MailHistoryUncheckedCreateWithoutApplicantInput>
  }

  export type MailHistoryUpdateWithWhereUniqueWithoutApplicantInput = {
    where: MailHistoryWhereUniqueInput
    data: XOR<MailHistoryUpdateWithoutApplicantInput, MailHistoryUncheckedUpdateWithoutApplicantInput>
  }

  export type MailHistoryUpdateManyWithWhereWithoutApplicantInput = {
    where: MailHistoryScalarWhereInput
    data: XOR<MailHistoryUpdateManyMutationInput, MailHistoryUncheckedUpdateManyWithoutApplicantInput>
  }

  export type ApplicantCreateWithoutSnsProfilesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutApplicantsInput
    selectionResults?: SelectionResultCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutSnsProfilesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaignId: string
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutSnsProfilesInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutSnsProfilesInput, ApplicantUncheckedCreateWithoutSnsProfilesInput>
  }

  export type ApplicantUpsertWithoutSnsProfilesInput = {
    update: XOR<ApplicantUpdateWithoutSnsProfilesInput, ApplicantUncheckedUpdateWithoutSnsProfilesInput>
    create: XOR<ApplicantCreateWithoutSnsProfilesInput, ApplicantUncheckedCreateWithoutSnsProfilesInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutSnsProfilesInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutSnsProfilesInput, ApplicantUncheckedUpdateWithoutSnsProfilesInput>
  }

  export type ApplicantUpdateWithoutSnsProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutApplicantsNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutSnsProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantCreateWithoutSelectionResultsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutApplicantsInput
    snsProfiles?: SNSProfileCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutSelectionResultsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaignId: string
    snsProfiles?: SNSProfileUncheckedCreateNestedManyWithoutApplicantInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutSelectionResultsInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutSelectionResultsInput, ApplicantUncheckedCreateWithoutSelectionResultsInput>
  }

  export type CampaignCreateWithoutSelectionResultsInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    applicants?: ApplicantCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSelectionResultsInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutCampaignInput
    mailHistories?: MailHistoryUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSelectionResultsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSelectionResultsInput, CampaignUncheckedCreateWithoutSelectionResultsInput>
  }

  export type ApplicantUpsertWithoutSelectionResultsInput = {
    update: XOR<ApplicantUpdateWithoutSelectionResultsInput, ApplicantUncheckedUpdateWithoutSelectionResultsInput>
    create: XOR<ApplicantCreateWithoutSelectionResultsInput, ApplicantUncheckedCreateWithoutSelectionResultsInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutSelectionResultsInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutSelectionResultsInput, ApplicantUncheckedUpdateWithoutSelectionResultsInput>
  }

  export type ApplicantUpdateWithoutSelectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutApplicantsNestedInput
    snsProfiles?: SNSProfileUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutSelectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    snsProfiles?: SNSProfileUncheckedUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type CampaignUpsertWithoutSelectionResultsInput = {
    update: XOR<CampaignUpdateWithoutSelectionResultsInput, CampaignUncheckedUpdateWithoutSelectionResultsInput>
    create: XOR<CampaignCreateWithoutSelectionResultsInput, CampaignUncheckedCreateWithoutSelectionResultsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSelectionResultsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSelectionResultsInput, CampaignUncheckedUpdateWithoutSelectionResultsInput>
  }

  export type CampaignUpdateWithoutSelectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    applicants?: ApplicantUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSelectionResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUncheckedUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ApplicantCreateWithoutMailHistoriesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutApplicantsInput
    snsProfiles?: SNSProfileCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutMailHistoriesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    campaignId: string
    snsProfiles?: SNSProfileUncheckedCreateNestedManyWithoutApplicantInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutMailHistoriesInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutMailHistoriesInput, ApplicantUncheckedCreateWithoutMailHistoriesInput>
  }

  export type CampaignCreateWithoutMailHistoriesInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    applicants?: ApplicantCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMailHistoriesInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    applicants?: ApplicantUncheckedCreateNestedManyWithoutCampaignInput
    selectionResults?: SelectionResultUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMailHistoriesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMailHistoriesInput, CampaignUncheckedCreateWithoutMailHistoriesInput>
  }

  export type ApplicantUpsertWithoutMailHistoriesInput = {
    update: XOR<ApplicantUpdateWithoutMailHistoriesInput, ApplicantUncheckedUpdateWithoutMailHistoriesInput>
    create: XOR<ApplicantCreateWithoutMailHistoriesInput, ApplicantUncheckedCreateWithoutMailHistoriesInput>
    where?: ApplicantWhereInput
  }

  export type ApplicantUpdateToOneWithWhereWithoutMailHistoriesInput = {
    where?: ApplicantWhereInput
    data: XOR<ApplicantUpdateWithoutMailHistoriesInput, ApplicantUncheckedUpdateWithoutMailHistoriesInput>
  }

  export type ApplicantUpdateWithoutMailHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutApplicantsNestedInput
    snsProfiles?: SNSProfileUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutMailHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    snsProfiles?: SNSProfileUncheckedUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type CampaignUpsertWithoutMailHistoriesInput = {
    update: XOR<CampaignUpdateWithoutMailHistoriesInput, CampaignUncheckedUpdateWithoutMailHistoriesInput>
    create: XOR<CampaignCreateWithoutMailHistoriesInput, CampaignUncheckedCreateWithoutMailHistoriesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMailHistoriesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMailHistoriesInput, CampaignUncheckedUpdateWithoutMailHistoriesInput>
  }

  export type CampaignUpdateWithoutMailHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    applicants?: ApplicantUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMailHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    applicants?: ApplicantUncheckedUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    sheetId?: string | null
    sheetName?: string | null
    sheetUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: ApplicantUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: ApplicantUncheckedUpdateManyWithoutCampaignNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutCampaignNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sheetId?: NullableStringFieldUpdateOperationsInput | string | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sheetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantCreateManyCampaignInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    applicationDate?: Date | string
    status?: $Enums.ApplicantStatus
    notes?: string | null
    sheetRowIndex: number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type SelectionResultCreateManyCampaignInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type MailHistoryCreateManyCampaignInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantId: string
  }

  export type ApplicantUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snsProfiles?: SNSProfileUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snsProfiles?: SNSProfileUncheckedUpdateManyWithoutApplicantNestedInput
    selectionResults?: SelectionResultUncheckedUpdateManyWithoutApplicantNestedInput
    mailHistories?: MailHistoryUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantStatusFieldUpdateOperationsInput | $Enums.ApplicantStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sheetRowIndex?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelectionResultUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
    applicant?: ApplicantUpdateOneRequiredWithoutSelectionResultsNestedInput
  }

  export type SelectionResultUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type MailHistoryUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: ApplicantUpdateOneRequiredWithoutMailHistoriesNestedInput
  }

  export type MailHistoryUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
  }

  export type MailHistoryUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantId?: StringFieldUpdateOperationsInput | string
  }

  export type SNSProfileCreateManyApplicantInput = {
    id?: string
    platform: $Enums.SNSPlatform
    url: string
    handle?: string | null
    followers?: number | null
    visitors?: number | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SelectionResultCreateManyApplicantInput = {
    id?: string
    isSelected: boolean
    selectionReason: string
    selectionDate?: Date | string
    qualifyingPlatforms: JsonNullValueInput | InputJsonValue
    processingStatus?: $Enums.ProcessingStatus
    sheetUpdated?: boolean
    sheetUpdateDate?: Date | string | null
    emailSent?: boolean
    emailSentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    meetsCriteria: JsonNullValueInput | InputJsonValue
    snsDataSnapshot: JsonNullValueInput | InputJsonValue
  }

  export type MailHistoryCreateManyApplicantInput = {
    id?: string
    mailType: $Enums.MailType
    recipient: string
    subject: string
    content: string
    status?: $Enums.MailStatus
    sentAt?: Date | string | null
    failReason?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type SNSProfileUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SNSProfileUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SNSProfileUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumSNSPlatformFieldUpdateOperationsInput | $Enums.SNSPlatform
    url?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    visitors?: NullableIntFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelectionResultUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
    campaign?: CampaignUpdateOneRequiredWithoutSelectionResultsNestedInput
  }

  export type SelectionResultUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type SelectionResultUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    selectionReason?: StringFieldUpdateOperationsInput | string
    selectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qualifyingPlatforms?: JsonNullValueInput | InputJsonValue
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    sheetUpdated?: BoolFieldUpdateOperationsInput | boolean
    sheetUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    meetsCriteria?: JsonNullValueInput | InputJsonValue
    snsDataSnapshot?: JsonNullValueInput | InputJsonValue
  }

  export type MailHistoryUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMailHistoriesNestedInput
  }

  export type MailHistoryUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type MailHistoryUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    mailType?: EnumMailTypeFieldUpdateOperationsInput | $Enums.MailType
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMailStatusFieldUpdateOperationsInput | $Enums.MailStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}